<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Corpus Cleaner: simdjson::fallback::ondemand::value Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Corpus Cleaner
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesimdjson.html">simdjson</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1fallback.html">fallback</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html">ondemand</a></li><li class="navelem"><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsimdjson_1_1fallback_1_1ondemand_1_1value-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simdjson::fallback::ondemand::value Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="simdjson_8h_source.html">simdjson.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0424228b9bf9936e9a425de05054093e" id="r_a0424228b9bf9936e9a425de05054093e"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0424228b9bf9936e9a425de05054093e">value</a> () noexcept=default</td></tr>
<tr class="separator:a0424228b9bf9936e9a425de05054093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516642be78954f52fbaa83886194f2e8" id="r_a516642be78954f52fbaa83886194f2e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a516642be78954f52fbaa83886194f2e8"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a516642be78954f52fbaa83886194f2e8">get</a> () noexcept</td></tr>
<tr class="separator:a516642be78954f52fbaa83886194f2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1319614333c15dfd74b7828211b97aa1" id="r_a1319614333c15dfd74b7828211b97aa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1319614333c15dfd74b7828211b97aa1"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1319614333c15dfd74b7828211b97aa1">get</a> (T &amp;out) noexcept</td></tr>
<tr class="separator:a1319614333c15dfd74b7828211b97aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9efb8a1581dc58e4618d952aa7b959" id="r_a5a9efb8a1581dc58e4618d952aa7b959"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a9efb8a1581dc58e4618d952aa7b959">get_array</a> () noexcept</td></tr>
<tr class="separator:a5a9efb8a1581dc58e4618d952aa7b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dfe793b72913f3a1bea76fb06e3b22" id="r_a08dfe793b72913f3a1bea76fb06e3b22"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08dfe793b72913f3a1bea76fb06e3b22">get_object</a> () noexcept</td></tr>
<tr class="separator:a08dfe793b72913f3a1bea76fb06e3b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2907e78cac3696db71b926c8de10f95" id="r_ac2907e78cac3696db71b926c8de10f95"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2907e78cac3696db71b926c8de10f95">get_uint64</a> () noexcept</td></tr>
<tr class="separator:ac2907e78cac3696db71b926c8de10f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772fedc13be084ebc9f5861873772643" id="r_a772fedc13be084ebc9f5861873772643"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772fedc13be084ebc9f5861873772643">get_uint64_in_string</a> () noexcept</td></tr>
<tr class="separator:a772fedc13be084ebc9f5861873772643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af254d95e4f539c12559a4b846aa7fb2a" id="r_af254d95e4f539c12559a4b846aa7fb2a"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af254d95e4f539c12559a4b846aa7fb2a">get_int64</a> () noexcept</td></tr>
<tr class="separator:af254d95e4f539c12559a4b846aa7fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a2a5c6217d1ac310881369e3165db0" id="r_a90a2a5c6217d1ac310881369e3165db0"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90a2a5c6217d1ac310881369e3165db0">get_int64_in_string</a> () noexcept</td></tr>
<tr class="separator:a90a2a5c6217d1ac310881369e3165db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3f0035ac1311eb8908ab1c433826d1" id="r_a1f3f0035ac1311eb8908ab1c433826d1"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f3f0035ac1311eb8908ab1c433826d1">get_double</a> () noexcept</td></tr>
<tr class="separator:a1f3f0035ac1311eb8908ab1c433826d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3522e3d1c38613ffdb79eeb240ba898" id="r_ac3522e3d1c38613ffdb79eeb240ba898"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3522e3d1c38613ffdb79eeb240ba898">get_double_in_string</a> () noexcept</td></tr>
<tr class="separator:ac3522e3d1c38613ffdb79eeb240ba898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc9e0e40f4a23cb182c55def0134f29" id="r_aedc9e0e40f4a23cb182c55def0134f29"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc9e0e40f4a23cb182c55def0134f29">get_string</a> (bool allow_replacement=false) noexcept</td></tr>
<tr class="separator:aedc9e0e40f4a23cb182c55def0134f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f083c1216e10bec543e50a103aab82f" id="r_a1f083c1216e10bec543e50a103aab82f"><td class="memTemplParams" colspan="2">template&lt;typename string_type &gt; </td></tr>
<tr class="memitem:a1f083c1216e10bec543e50a103aab82f"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f083c1216e10bec543e50a103aab82f">get_string</a> (string_type &amp;receiver, bool allow_replacement=false) noexcept</td></tr>
<tr class="separator:a1f083c1216e10bec543e50a103aab82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e395bdb28c394d87fe872f7aa7f543" id="r_ae1e395bdb28c394d87fe872f7aa7f543"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1e395bdb28c394d87fe872f7aa7f543">get_wobbly_string</a> () noexcept</td></tr>
<tr class="separator:ae1e395bdb28c394d87fe872f7aa7f543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459513c4f6d9c013b7d65e17ebe0e56f" id="r_a459513c4f6d9c013b7d65e17ebe0e56f"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string.html">raw_json_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a459513c4f6d9c013b7d65e17ebe0e56f">get_raw_json_string</a> () noexcept</td></tr>
<tr class="separator:a459513c4f6d9c013b7d65e17ebe0e56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3da3539957d22abbfab27ce038f6682" id="r_ab3da3539957d22abbfab27ce038f6682"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3da3539957d22abbfab27ce038f6682">get_bool</a> () noexcept</td></tr>
<tr class="separator:ab3da3539957d22abbfab27ce038f6682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1aa1a5d7c66f2ed88b959fe35173c0" id="r_a3b1aa1a5d7c66f2ed88b959fe35173c0"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1aa1a5d7c66f2ed88b959fe35173c0">is_null</a> () noexcept</td></tr>
<tr class="separator:a3b1aa1a5d7c66f2ed88b959fe35173c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0576708d7596079b74fdcfcb2a96ee15" id="r_a0576708d7596079b74fdcfcb2a96ee15"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0576708d7596079b74fdcfcb2a96ee15">begin</a> () &amp;noexcept</td></tr>
<tr class="separator:a0576708d7596079b74fdcfcb2a96ee15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0869e153b1810b039c79ec2ae1e8fa" id="r_a3d0869e153b1810b039c79ec2ae1e8fa"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d0869e153b1810b039c79ec2ae1e8fa">end</a> () &amp;noexcept</td></tr>
<tr class="separator:a3d0869e153b1810b039c79ec2ae1e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5380dccd952e4d0b0a0a31950c2e710" id="r_ac5380dccd952e4d0b0a0a31950c2e710"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5380dccd952e4d0b0a0a31950c2e710">count_elements</a> () &amp;noexcept</td></tr>
<tr class="separator:ac5380dccd952e4d0b0a0a31950c2e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f81c355be945fab1bde89b732ce85" id="r_aaa2f81c355be945fab1bde89b732ce85"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa2f81c355be945fab1bde89b732ce85">count_fields</a> () &amp;noexcept</td></tr>
<tr class="separator:aaa2f81c355be945fab1bde89b732ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12dc3307c264d065a75f5dc33806b85" id="r_ae12dc3307c264d065a75f5dc33806b85"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12dc3307c264d065a75f5dc33806b85">at</a> (size_t index) noexcept</td></tr>
<tr class="separator:ae12dc3307c264d065a75f5dc33806b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97c913c1c63aa030e55ecab34e80481" id="r_ad97c913c1c63aa030e55ecab34e80481"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad97c913c1c63aa030e55ecab34e80481">find_field</a> (std::string_view key) noexcept</td></tr>
<tr class="separator:ad97c913c1c63aa030e55ecab34e80481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4087ea33a53a19a7b4de4588043e211" id="r_aa4087ea33a53a19a7b4de4588043e211"><td class="memItemLeft" align="right" valign="top"><a id="aa4087ea33a53a19a7b4de4588043e211" name="aa4087ea33a53a19a7b4de4588043e211"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_field</b> (const char *key) noexcept</td></tr>
<tr class="separator:aa4087ea33a53a19a7b4de4588043e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0015c70a638fdd4812a2be3c9f64f1ca" id="r_a0015c70a638fdd4812a2be3c9f64f1ca"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0015c70a638fdd4812a2be3c9f64f1ca">find_field_unordered</a> (std::string_view key) noexcept</td></tr>
<tr class="separator:a0015c70a638fdd4812a2be3c9f64f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe872fa31a417bb2bd8c61ffb6652e" id="r_a45fe872fa31a417bb2bd8c61ffb6652e"><td class="memItemLeft" align="right" valign="top"><a id="a45fe872fa31a417bb2bd8c61ffb6652e" name="a45fe872fa31a417bb2bd8c61ffb6652e"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_unordered</b> (const char *key) noexcept</td></tr>
<tr class="separator:a45fe872fa31a417bb2bd8c61ffb6652e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee9d96f082903cbd05ffca83b1e8ca5" id="r_acee9d96f082903cbd05ffca83b1e8ca5"><td class="memItemLeft" align="right" valign="top"><a id="acee9d96f082903cbd05ffca83b1e8ca5" name="acee9d96f082903cbd05ffca83b1e8ca5"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (std::string_view key) noexcept</td></tr>
<tr class="separator:acee9d96f082903cbd05ffca83b1e8ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5be5e8164c068e8d0e6d1732de0ac46" id="r_ad5be5e8164c068e8d0e6d1732de0ac46"><td class="memItemLeft" align="right" valign="top"><a id="ad5be5e8164c068e8d0e6d1732de0ac46" name="ad5be5e8164c068e8d0e6d1732de0ac46"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const char *key) noexcept</td></tr>
<tr class="separator:ad5be5e8164c068e8d0e6d1732de0ac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871bd06caa8f3a24329716f193a83f88" id="r_a871bd06caa8f3a24329716f193a83f88"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037e">json_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a871bd06caa8f3a24329716f193a83f88">type</a> () noexcept</td></tr>
<tr class="separator:a871bd06caa8f3a24329716f193a83f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e85700ea22dd94b6d5fe290cbb58ced" id="r_a0e85700ea22dd94b6d5fe290cbb58ced"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e85700ea22dd94b6d5fe290cbb58ced">is_scalar</a> () noexcept</td></tr>
<tr class="separator:a0e85700ea22dd94b6d5fe290cbb58ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d85d6edcbf5d273153af35618a1ddc9" id="r_a1d85d6edcbf5d273153af35618a1ddc9"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d85d6edcbf5d273153af35618a1ddc9">is_string</a> () noexcept</td></tr>
<tr class="separator:a1d85d6edcbf5d273153af35618a1ddc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c957af2128212cdb802b2b4336e70" id="r_a692c957af2128212cdb802b2b4336e70"><td class="memItemLeft" align="right" valign="top">simdjson_inline bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692c957af2128212cdb802b2b4336e70">is_negative</a> () noexcept</td></tr>
<tr class="separator:a692c957af2128212cdb802b2b4336e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783689de68b6209fdb0605b972e63dd2" id="r_a783689de68b6209fdb0605b972e63dd2"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a783689de68b6209fdb0605b972e63dd2">is_integer</a> () noexcept</td></tr>
<tr class="separator:a783689de68b6209fdb0605b972e63dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cd379581a61b862ee956bc5f3b741a" id="r_a15cd379581a61b862ee956bc5f3b741a"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4e">number_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type</a> () noexcept</td></tr>
<tr class="separator:a15cd379581a61b862ee956bc5f3b741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452bc355b01b17ec3e08da4293f97601" id="r_a452bc355b01b17ec3e08da4293f97601"><td class="memItemLeft" align="right" valign="top">simdjson_warn_unused simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html">number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452bc355b01b17ec3e08da4293f97601">get_number</a> () noexcept</td></tr>
<tr class="separator:a452bc355b01b17ec3e08da4293f97601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646f492ee8e480e4bb210b14cf5124f" id="r_a5646f492ee8e480e4bb210b14cf5124f"><td class="memItemLeft" align="right" valign="top">simdjson_inline std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5646f492ee8e480e4bb210b14cf5124f">raw_json_token</a> () noexcept</td></tr>
<tr class="separator:a5646f492ee8e480e4bb210b14cf5124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5a435df727ef09398d56a848674818" id="r_a1a5a435df727ef09398d56a848674818"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5a435df727ef09398d56a848674818">raw_json</a> () noexcept</td></tr>
<tr class="separator:a1a5a435df727ef09398d56a848674818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b92c9873051c1b532ffbc76e3fdedf" id="r_a94b92c9873051c1b532ffbc76e3fdedf"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94b92c9873051c1b532ffbc76e3fdedf">current_location</a> () noexcept</td></tr>
<tr class="separator:a94b92c9873051c1b532ffbc76e3fdedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c60a2810dc70a7e207a252e2bd4c22" id="r_a61c60a2810dc70a7e207a252e2bd4c22"><td class="memItemLeft" align="right" valign="top">simdjson_inline int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61c60a2810dc70a7e207a252e2bd4c22">current_depth</a> () const noexcept</td></tr>
<tr class="separator:a61c60a2810dc70a7e207a252e2bd4c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd66299b03f37b289dca52773f31df5" id="r_a3cd66299b03f37b289dca52773f31df5"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd66299b03f37b289dca52773f31df5">at_pointer</a> (std::string_view json_pointer) noexcept</td></tr>
<tr class="separator:a3cd66299b03f37b289dca52773f31df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bc4d4fac30a4e51eb4e7633f59822a" id="r_a87bc4d4fac30a4e51eb4e7633f59822a"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87bc4d4fac30a4e51eb4e7633f59822a">at_path</a> (std::string_view at_path) noexcept</td></tr>
<tr class="separator:a87bc4d4fac30a4e51eb4e7633f59822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185ed502e5a110a2512eb98c0afedfc" id="r_ab185ed502e5a110a2512eb98c0afedfc"><td class="memItemLeft" align="right" valign="top"><a id="ab185ed502e5a110a2512eb98c0afedfc" name="ab185ed502e5a110a2512eb98c0afedfc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab185ed502e5a110a2512eb98c0afedfc"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:ab185ed502e5a110a2512eb98c0afedfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5963efef188c4d63282815d17aa5076" id="r_ac5963efef188c4d63282815d17aa5076"><td class="memItemLeft" align="right" valign="top"><a id="ac5963efef188c4d63282815d17aa5076" name="ac5963efef188c4d63282815d17aa5076"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac5963efef188c4d63282815d17aa5076"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:ac5963efef188c4d63282815d17aa5076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043da2b381183a65375e66e3c2a253f3" id="r_a043da2b381183a65375e66e3c2a253f3"><td class="memItemLeft" align="right" valign="top"><a id="a043da2b381183a65375e66e3c2a253f3" name="a043da2b381183a65375e66e3c2a253f3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a043da2b381183a65375e66e3c2a253f3"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string.html">raw_json_string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:a043da2b381183a65375e66e3c2a253f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c433072835c8e9c7d40fd5f6d03bf5f" id="r_a2c433072835c8e9c7d40fd5f6d03bf5f"><td class="memItemLeft" align="right" valign="top"><a id="a2c433072835c8e9c7d40fd5f6d03bf5f" name="a2c433072835c8e9c7d40fd5f6d03bf5f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2c433072835c8e9c7d40fd5f6d03bf5f"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:a2c433072835c8e9c7d40fd5f6d03bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7197aa56381cfbbfa18cae82bc1aa694" id="r_a7197aa56381cfbbfa18cae82bc1aa694"><td class="memItemLeft" align="right" valign="top"><a id="a7197aa56381cfbbfa18cae82bc1aa694" name="a7197aa56381cfbbfa18cae82bc1aa694"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7197aa56381cfbbfa18cae82bc1aa694"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html">number</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:a7197aa56381cfbbfa18cae82bc1aa694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec03bcb72568ba17aa42324ed5cb596" id="r_acec03bcb72568ba17aa42324ed5cb596"><td class="memItemLeft" align="right" valign="top"><a id="acec03bcb72568ba17aa42324ed5cb596" name="acec03bcb72568ba17aa42324ed5cb596"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acec03bcb72568ba17aa42324ed5cb596"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:acec03bcb72568ba17aa42324ed5cb596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f37df4a6728d0b0b8a1133b20919d4" id="r_a06f37df4a6728d0b0b8a1133b20919d4"><td class="memItemLeft" align="right" valign="top"><a id="a06f37df4a6728d0b0b8a1133b20919d4" name="a06f37df4a6728d0b0b8a1133b20919d4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a06f37df4a6728d0b0b8a1133b20919d4"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:a06f37df4a6728d0b0b8a1133b20919d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d37474ac185819e1b6a54a71d75dbdd" id="r_a2d37474ac185819e1b6a54a71d75dbdd"><td class="memItemLeft" align="right" valign="top"><a id="a2d37474ac185819e1b6a54a71d75dbdd" name="a2d37474ac185819e1b6a54a71d75dbdd"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2d37474ac185819e1b6a54a71d75dbdd"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:a2d37474ac185819e1b6a54a71d75dbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b22b19e10ae2490c908025519b5e131" id="r_a9b22b19e10ae2490c908025519b5e131"><td class="memItemLeft" align="right" valign="top"><a id="a9b22b19e10ae2490c908025519b5e131" name="a9b22b19e10ae2490c908025519b5e131"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9b22b19e10ae2490c908025519b5e131"><td class="memTemplItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () noexcept</td></tr>
<tr class="separator:a9b22b19e10ae2490c908025519b5e131"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a591666a962f35a69349b704fb712addc" id="r_a591666a962f35a69349b704fb712addc"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591666a962f35a69349b704fb712addc">value</a> (const value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a591666a962f35a69349b704fb712addc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89745bb8e4dca4427d5928989cda2914" id="r_a89745bb8e4dca4427d5928989cda2914"><td class="memItemLeft" align="right" valign="top">simdjson_inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89745bb8e4dca4427d5928989cda2914">skip</a> () noexcept</td></tr>
<tr class="separator:a89745bb8e4dca4427d5928989cda2914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee5e148acc7524b2864c2c0ca96893a" id="r_aaee5e148acc7524b2864c2c0ca96893a"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee5e148acc7524b2864c2c0ca96893a">start_or_resume_object</a> () noexcept</td></tr>
<tr class="separator:aaee5e148acc7524b2864c2c0ca96893a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a50b49989393da6777ea6bace184470d0" id="r_a50b49989393da6777ea6bace184470d0"><td class="memItemLeft" align="right" valign="top">static simdjson_inline <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50b49989393da6777ea6bace184470d0">start</a> (const value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a50b49989393da6777ea6bace184470d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fdf8190a2baec7150c28e48bd262b1" id="r_a65fdf8190a2baec7150c28e48bd262b1"><td class="memItemLeft" align="right" valign="top">static simdjson_inline <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65fdf8190a2baec7150c28e48bd262b1">resume</a> (const value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a65fdf8190a2baec7150c28e48bd262b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7eb1b097510465287e1be54499fd8acd" id="r_a7eb1b097510465287e1be54499fd8acd"><td class="memItemLeft" align="right" valign="top"><a id="a7eb1b097510465287e1be54499fd8acd" name="a7eb1b097510465287e1be54499fd8acd"></a>
value_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iter</b> {}</td></tr>
<tr class="separator:a7eb1b097510465287e1be54499fd8acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7c20332b4481f29ace969e40cfce5f5f" id="r_a7c20332b4481f29ace969e40cfce5f5f"><td class="memItemLeft" align="right" valign="top"><a id="a7c20332b4481f29ace969e40cfce5f5f" name="a7c20332b4481f29ace969e40cfce5f5f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>document</b></td></tr>
<tr class="separator:a7c20332b4481f29ace969e40cfce5f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7be9f74f64c08fae57eaf36044f7a9" id="r_aec7be9f74f64c08fae57eaf36044f7a9"><td class="memItemLeft" align="right" valign="top"><a id="aec7be9f74f64c08fae57eaf36044f7a9" name="aec7be9f74f64c08fae57eaf36044f7a9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>array_iterator</b></td></tr>
<tr class="separator:aec7be9f74f64c08fae57eaf36044f7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62af17df5486963eef933792624216d" id="r_ad62af17df5486963eef933792624216d"><td class="memItemLeft" align="right" valign="top"><a id="ad62af17df5486963eef933792624216d" name="ad62af17df5486963eef933792624216d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>field</b></td></tr>
<tr class="separator:ad62af17df5486963eef933792624216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4dcacb8171b99f783396bb6a337c65" id="r_a3d4dcacb8171b99f783396bb6a337c65"><td class="memItemLeft" align="right" valign="top"><a id="a3d4dcacb8171b99f783396bb6a337c65" name="a3d4dcacb8171b99f783396bb6a337c65"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>object</b></td></tr>
<tr class="separator:a3d4dcacb8171b99f783396bb6a337c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad87deba0e08e8188b26485164889fb" id="r_a9ad87deba0e08e8188b26485164889fb"><td class="memItemLeft" align="right" valign="top"><a id="a9ad87deba0e08e8188b26485164889fb" name="a9ad87deba0e08e8188b26485164889fb"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>simdjson_result&lt; value &gt;</b></td></tr>
<tr class="separator:a9ad87deba0e08e8188b26485164889fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91f0ec4a1944cba079924b366424f89" id="r_ac91f0ec4a1944cba079924b366424f89"><td class="memItemLeft" align="right" valign="top"><a id="ac91f0ec4a1944cba079924b366424f89" name="ac91f0ec4a1944cba079924b366424f89"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>simdjson_result&lt; field &gt;</b></td></tr>
<tr class="separator:ac91f0ec4a1944cba079924b366424f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An ephemeral JSON value returned during iteration. It is only valid for as long as you do not access more data in the JSON document. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0424228b9bf9936e9a425de05054093e" name="a0424228b9bf9936e9a425de05054093e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0424228b9bf9936e9a425de05054093e">&#9670;&#160;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::fallback::ondemand::value::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new invalid value.</p>
<p>Exists so you can declare a variable and later assign to it before use. </p>

</div>
</div>
<a id="a591666a962f35a69349b704fb712addc" name="a591666a962f35a69349b704fb712addc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591666a962f35a69349b704fb712addc">&#9670;&#160;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::fallback::ondemand::value::value </td>
          <td>(</td>
          <td class="paramtype">const value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a value. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae12dc3307c264d065a75f5dc33806b85" name="ae12dc3307c264d065a75f5dc33806b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12dc3307c264d065a75f5dc33806b85">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::value::at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value at the given index in the array. This function has linear-time complexity. This function should only be called once on an array instance since the array iterator is not reset between each call.</p>
<dl class="section return"><dt>Returns</dt><dd>The value at the given index, or:<ul>
<li>INDEX_OUT_OF_BOUNDS if the array index is larger than an array length </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a87bc4d4fac30a4e51eb4e7633f59822a" name="a87bc4d4fac30a4e51eb4e7633f59822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bc4d4fac30a4e51eb4e7633f59822a">&#9670;&#160;</a></span>at_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::value::at_path </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>at_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value associated with the given JSONPath expression. We only support JSONPath queries that trivially convertible to JSON Pointer queries: key names and array indices.</p>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the given JSONPath expression, or:<ul>
<li>INVALID_JSON_POINTER if the JSONPath to JSON Pointer conversion fails</li>
<li>NO_SUCH_FIELD if a field does not exist in an object</li>
<li>INDEX_OUT_OF_BOUNDS if an array index is larger than an array length</li>
<li>INCORRECT_TYPE if a non-integer is used to access an array </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3cd66299b03f37b289dca52773f31df5" name="a3cd66299b03f37b289dca52773f31df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd66299b03f37b289dca52773f31df5">&#9670;&#160;</a></span>at_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::value::at_pointer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>json_pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value associated with the given JSON pointer. We use the RFC 6901 <a href="https://tools.ietf.org/html/rfc6901">https://tools.ietf.org/html/rfc6901</a> standard.</p>
<p><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">ondemand::parser</a> parser; auto json = R"({ "foo": { "a": [ 10, 20, 30 ] }})"_padded; auto doc = parser.iterate(json); doc.at_pointer("/foo/a/1") == 20</p>
<p>It is allowed for a key to be the empty string:</p>
<p><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">ondemand::parser</a> parser; auto json = R"({ "": { "a": [ 10, 20, 30 ] }})"_padded; auto doc = parser.iterate(json); doc.at_pointer("//a/1") == 20</p>
<p>Note that <a class="el" href="#a3cd66299b03f37b289dca52773f31df5">at_pointer()</a> called on the document automatically calls the document's rewind method between each call. It invalidates all previously accessed arrays, objects and values that have not been consumed.</p>
<p>Calling <a class="el" href="#a3cd66299b03f37b289dca52773f31df5">at_pointer()</a> on non-document instances (e.g., arrays and objects) is not standardized (by RFC 6901). We provide some experimental support for JSON pointers on non-document instances. Yet it is not the case when calling at_pointer on an array or an object instance: there is no rewind and no invalidation.</p>
<p>You may only call at_pointer on an array after it has been created, but before it has been first accessed. When calling at_pointer on an array, the pointer is advanced to the location indicated by the JSON pointer (in case of success). It is no longer possible to call at_pointer on the same array.</p>
<p>You may call at_pointer more than once on an object, but each time the pointer is advanced to be within the value matched by the key indicated by the JSON pointer query. Thus any preceding key (as well as the current key) can no longer be used with following JSON pointer calls.</p>
<p>Also note that <a class="el" href="#a3cd66299b03f37b289dca52773f31df5">at_pointer()</a> relies on <a class="el" href="#ad97c913c1c63aa030e55ecab34e80481">find_field()</a> which implies that we do not unescape keys when matching</p>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the given JSON pointer, or:<ul>
<li>NO_SUCH_FIELD if a field does not exist in an object</li>
<li>INDEX_OUT_OF_BOUNDS if an array index is larger than an array length</li>
<li>INCORRECT_TYPE if a non-integer is used to access an array</li>
<li>INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0576708d7596079b74fdcfcb2a96ee15" name="a0576708d7596079b74fdcfcb2a96ee15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0576708d7596079b74fdcfcb2a96ee15">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt; simdjson::fallback::ondemand::value::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin array iteration.</p>
<p>Part of the std::iterable interface.</p>
<dl class="section return"><dt>Returns</dt><dd>INCORRECT_TYPE If the JSON value is not an array. </dd></dl>

</div>
</div>
<a id="ac5380dccd952e4d0b0a0a31950c2e710" name="ac5380dccd952e4d0b0a0a31950c2e710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5380dccd952e4d0b0a0a31950c2e710">&#9670;&#160;</a></span>count_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt; simdjson::fallback::ondemand::value::count_elements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method scans the array and counts the number of elements. The count_elements method should always be called before you have begun iterating through the array: it is expected that you are pointing at the beginning of the array. The runtime complexity is linear in the size of the array. After calling this function, if successful, the array is 'rewinded' at its beginning as if it had never been accessed. If the JSON is malformed (e.g., there is a missing comma), then an error is returned and it is no longer safe to continue.</p>
<p>Performance hint: You should only call <a class="el" href="#ac5380dccd952e4d0b0a0a31950c2e710">count_elements()</a> as a last resort as it may require scanning the document twice or more. </p>

</div>
</div>
<a id="aaa2f81c355be945fab1bde89b732ce85" name="aaa2f81c355be945fab1bde89b732ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f81c355be945fab1bde89b732ce85">&#9670;&#160;</a></span>count_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt; simdjson::fallback::ondemand::value::count_fields </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method scans the object and counts the number of key-value pairs. The count_fields method should always be called before you have begun iterating through the object: it is expected that you are pointing at the beginning of the object. The runtime complexity is linear in the size of the object. After calling this function, if successful, the object is 'rewinded' at its beginning as if it had never been accessed. If the JSON is malformed (e.g., there is a missing comma), then an error is returned and it is no longer safe to continue.</p>
<p>To check that an object is empty, it is more performant to use the is_empty() method on the object instance.</p>
<p>Performance hint: You should only call <a class="el" href="#aaa2f81c355be945fab1bde89b732ce85">count_fields()</a> as a last resort as it may require scanning the document twice or more. </p>

</div>
</div>
<a id="a61c60a2810dc70a7e207a252e2bd4c22" name="a61c60a2810dc70a7e207a252e2bd4c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c60a2810dc70a7e207a252e2bd4c22">&#9670;&#160;</a></span>current_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline int32_t simdjson::fallback::ondemand::value::current_depth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current depth in the document if in bounds.</p>
<p>E.g., 0 = finished with document 1 = document root value (could be [ or {, not yet known) 2 = , or } inside root array/object 3 = key or value inside root array/object. </p>

</div>
</div>
<a id="a94b92c9873051c1b532ffbc76e3fdedf" name="a94b92c9873051c1b532ffbc76e3fdedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b92c9873051c1b532ffbc76e3fdedf">&#9670;&#160;</a></span>current_location()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; const char * &gt; simdjson::fallback::ondemand::value::current_location </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current location in the document if in bounds. </p>

</div>
</div>
<a id="a3d0869e153b1810b039c79ec2ae1e8fa" name="a3d0869e153b1810b039c79ec2ae1e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0869e153b1810b039c79ec2ae1e8fa">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt; simdjson::fallback::ondemand::value::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sentinel representing the end of the array.</p>
<p>Part of the std::iterable interface. </p>

</div>
</div>
<a id="ad97c913c1c63aa030e55ecab34e80481" name="ad97c913c1c63aa030e55ecab34e80481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97c913c1c63aa030e55ecab34e80481">&#9670;&#160;</a></span>find_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::value::find_field </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up a field by name on an object (order-sensitive).</p>
<p>The following code reads z, then y, then x, and thus will not retrieve x or y if fed the JSON <code>{ "x": 1, "y": 2, "z": 3 }</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">simdjson::ondemand::parser <a class="code hl_class" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">parser</a>;</div>
<div class="line"><span class="keyword">auto</span> obj = <a class="code hl_class" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">parser</a>.parse(R<span class="stringliteral">&quot;( { &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 } )&quot;_padded);</span></div>
<div class="line"><span class="stringliteral"></span><span class="keywordtype">double</span> z = obj.find_field(<span class="stringliteral">&quot;z&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> y = obj.find_field(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> x = obj.find_field(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="ttc" id="aclasssimdjson_1_1fallback_1_1ondemand_1_1parser_html"><div class="ttname"><a href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">simdjson::fallback::ondemand::parser</a></div><div class="ttdef"><b>Definition</b> simdjson.h:38759</div></div>
</div><!-- fragment --><p> If you have multiple fields with a matching key ({"x": 1, "x": 1}) be mindful that only one field is returned.</p>
<p><b>Raw Keys:</b> The lookup will be done against the <em>raw</em> key, and will not unescape keys. e.g. <code>object["a"]</code> will match <code>{ "a": 1 }</code>, but will <em>not</em> match <code>{ "\u0061": 1 }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field, or NO_SUCH_FIELD if the field is not in the object.</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

</div>
</div>
<a id="a0015c70a638fdd4812a2be3c9f64f1ca" name="a0015c70a638fdd4812a2be3c9f64f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0015c70a638fdd4812a2be3c9f64f1ca">&#9670;&#160;</a></span>find_field_unordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::value::find_field_unordered </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up a field by name on an object, without regard to key order.</p>
<p><b>Performance Notes:</b> This is a bit less performant than <a class="el" href="#ad97c913c1c63aa030e55ecab34e80481">find_field()</a>, though its effect varies and often appears negligible. It starts out normally, starting out at the last field; but if the field is not found, it scans from the beginning of the object to see if it missed it. That missing case has a non-cache-friendly bump and lots of extra scanning, especially if the object in question is large. The fact that the extra code is there also bumps the executable size.</p>
<p>It is the default, however, because it would be highly surprising (and hard to debug) if the default behavior failed to look up a field just because it was in the wrong order&ndash;and many APIs assume this. Therefore, you must be explicit if you want to treat objects as out of order.</p>
<p>If you have multiple fields with a matching key ({"x": 1, "x": 1}) be mindful that only one field is returned.</p>
<p>Use <a class="el" href="#ad97c913c1c63aa030e55ecab34e80481">find_field()</a> if you are sure fields will be in order (or are willing to treat it as if the field as not there when they are not in order).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field, or NO_SUCH_FIELD if the field is not in the object.</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

</div>
</div>
<a id="a516642be78954f52fbaa83886194f2e8" name="a516642be78954f52fbaa83886194f2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516642be78954f52fbaa83886194f2e8">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; T &gt; simdjson::fallback::ondemand::value::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get this value as the given type.</p>
<p>Supported types: object, array, <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string.html">raw_json_string</a>, string_view, uint64_t, int64_t, double, bool</p>
<p>You may use <a class="el" href="#a1f3f0035ac1311eb8908ab1c433826d1">get_double()</a>, <a class="el" href="#ab3da3539957d22abbfab27ce038f6682">get_bool()</a>, <a class="el" href="#ac2907e78cac3696db71b926c8de10f95">get_uint64()</a>, <a class="el" href="#af254d95e4f539c12559a4b846aa7fb2a">get_int64()</a>, <a class="el" href="#a08dfe793b72913f3a1bea76fb06e3b22">get_object()</a>, <a class="el" href="#a5a9efb8a1581dc58e4618d952aa7b959">get_array()</a>, <a class="el" href="#a459513c4f6d9c013b7d65e17ebe0e56f">get_raw_json_string()</a>, or <a class="el" href="#aedc9e0e40f4a23cb182c55def0134f29">get_string()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A value of the given type, parsed from the JSON. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not the given type. </dd></dl>

</div>
</div>
<a id="a1319614333c15dfd74b7828211b97aa1" name="a1319614333c15dfd74b7828211b97aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1319614333c15dfd74b7828211b97aa1">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a> simdjson::fallback::ondemand::value::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get this value as the given type.</p>
<p>Supported types: object, array, <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string.html">raw_json_string</a>, string_view, uint64_t, int64_t, double, bool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>This is set to a value of the given type, parsed from the JSON. If there is an error, this may not be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>INCORRECT_TYPE If the JSON value is not an object. </dd>
<dd>
SUCCESS If the parse succeeded and the out parameter was set to the value. </dd></dl>

</div>
</div>
<a id="a5a9efb8a1581dc58e4618d952aa7b959" name="a5a9efb8a1581dc58e4618d952aa7b959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9efb8a1581dc58e4618d952aa7b959">&#9670;&#160;</a></span>get_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt; simdjson::fallback::ondemand::value::get_array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to an array.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that can be used to iterate the array. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not an array. </dd></dl>

</div>
</div>
<a id="ab3da3539957d22abbfab27ce038f6682" name="ab3da3539957d22abbfab27ce038f6682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3da3539957d22abbfab27ce038f6682">&#9670;&#160;</a></span>get_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::value::get_bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to a bool.</p>
<dl class="section return"><dt>Returns</dt><dd>A bool value. </dd>
<dd>
INCORRECT_TYPE if the JSON value is not true or false. </dd></dl>

</div>
</div>
<a id="a1f3f0035ac1311eb8908ab1c433826d1" name="a1f3f0035ac1311eb8908ab1c433826d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3f0035ac1311eb8908ab1c433826d1">&#9670;&#160;</a></span>get_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; double &gt; simdjson::fallback::ondemand::value::get_double </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to a double.</p>
<dl class="section return"><dt>Returns</dt><dd>A double. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not a valid floating-point number. </dd></dl>

</div>
</div>
<a id="ac3522e3d1c38613ffdb79eeb240ba898" name="ac3522e3d1c38613ffdb79eeb240ba898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3522e3d1c38613ffdb79eeb240ba898">&#9670;&#160;</a></span>get_double_in_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; double &gt; simdjson::fallback::ondemand::value::get_double_in_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value (inside string) to a double</p>
<dl class="section return"><dt>Returns</dt><dd>A double. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not a valid floating-point number. </dd></dl>

</div>
</div>
<a id="af254d95e4f539c12559a4b846aa7fb2a" name="af254d95e4f539c12559a4b846aa7fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af254d95e4f539c12559a4b846aa7fb2a">&#9670;&#160;</a></span>get_int64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; int64_t &gt; simdjson::fallback::ondemand::value::get_int64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to a signed integer.</p>
<dl class="section return"><dt>Returns</dt><dd>A signed 64-bit integer. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not a 64-bit integer. </dd></dl>

</div>
</div>
<a id="a90a2a5c6217d1ac310881369e3165db0" name="a90a2a5c6217d1ac310881369e3165db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a2a5c6217d1ac310881369e3165db0">&#9670;&#160;</a></span>get_int64_in_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; int64_t &gt; simdjson::fallback::ondemand::value::get_int64_in_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value (inside string) to a signed integer.</p>
<dl class="section return"><dt>Returns</dt><dd>A signed 64-bit integer. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not a 64-bit integer. </dd></dl>

</div>
</div>
<a id="a452bc355b01b17ec3e08da4293f97601" name="a452bc355b01b17ec3e08da4293f97601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452bc355b01b17ec3e08da4293f97601">&#9670;&#160;</a></span>get_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_warn_unused simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html">number</a> &gt; simdjson::fallback::ondemand::value::get_number </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to parse an <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html">ondemand::number</a>. An <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html">ondemand::number</a> may contain an integer value or a floating-point value, the simdjson library will autodetect the type. Thus it is a dynamically typed number. Before accessing the value, you must determine the detected type.</p>
<p><a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a340a27ec63f4345e23118d219b1c25c0">number.get_number_type()</a> is <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4eaa14b6141855cd58c670ca6559c75c941" title="a binary64 number">number_type::signed_integer</a> if we have an integer in [-9223372036854775808,9223372036854775808) You can recover the value by calling <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a507bf3678988d64c3c0261fc7c8ea453">number.get_int64()</a> and you have that <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#ac9a9e6991e11203a80e1e727b8622a49">number.is_int64()</a> is true.</p>
<p><a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a340a27ec63f4345e23118d219b1c25c0">number.get_number_type()</a> is <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4ea7383104b83254a99f5991d0ac77a6666" title="a signed integer that fits in a 64-bit word using two&#39;s complement">number_type::unsigned_integer</a> if we have an integer in [9223372036854775808,18446744073709551616) You can recover the value by calling <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a06b32b82e9014854a961c08e5dcd9866">number.get_uint64()</a> and you have that <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a2b47a1ef344b7d0721aa75dd05f3495d">number.is_uint64()</a> is true.</p>
<p>For integers that do not fit in 64 bits, the function returns BIGINT_ERROR error code.</p>
<p>Otherwise, <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a340a27ec63f4345e23118d219b1c25c0">number.get_number_type()</a> has value number_type::floating_point_number and we have a binary64 number. You can recover the value by calling <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#aad43855b3674bec7d414034774b77c4c">number.get_double()</a> and you have that <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#aa25cd8f6c60d7b4575223536f6a33dc0">number.is_double()</a> is true.</p>
<p>You must check the type before accessing the value: it is an error to call "get_int64()" when <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#a340a27ec63f4345e23118d219b1c25c0">number.get_number_type()</a> is not <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4eaa14b6141855cd58c670ca6559c75c941" title="a binary64 number">number_type::signed_integer</a> and when <a class="el" href="structsimdjson_1_1fallback_1_1ondemand_1_1number.html#ac9a9e6991e11203a80e1e727b8622a49">number.is_int64()</a> is false.</p>
<p>Performance note: this is designed with performance in mind. When calling '<a class="el" href="#a452bc355b01b17ec3e08da4293f97601">get_number()</a>', you scan the number string only once, determining efficiently the type and storing it in an efficient manner. </p>

</div>
</div>
<a id="a15cd379581a61b862ee956bc5f3b741a" name="a15cd379581a61b862ee956bc5f3b741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cd379581a61b862ee956bc5f3b741a">&#9670;&#160;</a></span>get_number_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_warn_unused simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4e">number_type</a> &gt; simdjson::fallback::ondemand::value::get_number_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the number type (integer or floating-point number) as quickly as possible. This function does not fully validate the input. It is useful when you only need to classify the numbers, without parsing them.</p>
<p>If you are planning to retrieve the value or you need full validation, consider using the <a class="el" href="#a452bc355b01b17ec3e08da4293f97601">get_number()</a> method instead: it will fully parse and validate the input, and give you access to the type: <a class="el" href="#a452bc355b01b17ec3e08da4293f97601">get_number()</a>.<a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type()</a>.</p>
<p><a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type()</a> is <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4ea7383104b83254a99f5991d0ac77a6666" title="a signed integer that fits in a 64-bit word using two&#39;s complement">number_type::unsigned_integer</a> if we have an integer greater or equal to 9223372036854775808. <a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type()</a> is <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4eaa14b6141855cd58c670ca6559c75c941" title="a binary64 number">number_type::signed_integer</a> if we have an integer that is less than 9223372036854775808. <a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type()</a> is <a class="el" href="namespacesimdjson_1_1fallback.html#a0d15f270b60e4d491abb937946737e4eae31b13bfd9383fa5b4dce96caa6a3e2c" title="a positive integer larger or equal to 1&lt;&lt;63">number_type::big_integer</a> for integers that do not fit in 64 bits, in which case the digit_count is set to the length of the big integer string. Otherwise, <a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type()</a> has value number_type::floating_point_number.</p>
<p>This function requires processing the number string, but it is expected to be faster than <a class="el" href="#a452bc355b01b17ec3e08da4293f97601">get_number()</a>.<a class="el" href="#a15cd379581a61b862ee956bc5f3b741a">get_number_type()</a> because it is does not parse the number value.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of the number </dd></dl>

</div>
</div>
<a id="a08dfe793b72913f3a1bea76fb06e3b22" name="a08dfe793b72913f3a1bea76fb06e3b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dfe793b72913f3a1bea76fb06e3b22">&#9670;&#160;</a></span>get_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt; simdjson::fallback::ondemand::value::get_object </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to an object.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that can be used to look up or iterate fields. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not an object. </dd></dl>

</div>
</div>
<a id="a459513c4f6d9c013b7d65e17ebe0e56f" name="a459513c4f6d9c013b7d65e17ebe0e56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459513c4f6d9c013b7d65e17ebe0e56f">&#9670;&#160;</a></span>get_raw_json_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string.html">raw_json_string</a> &gt; simdjson::fallback::ondemand::value::get_raw_json_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to a <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string.html">raw_json_string</a>.</p>
<p>The string is guaranteed to be valid UTF-8, and may have escapes in it (e.g. \ or <br  />
).</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the raw JSON for the given string. </dd>
<dd>
INCORRECT_TYPE if the JSON value is not a string. </dd></dl>

</div>
</div>
<a id="aedc9e0e40f4a23cb182c55def0134f29" name="aedc9e0e40f4a23cb182c55def0134f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc9e0e40f4a23cb182c55def0134f29">&#9670;&#160;</a></span>get_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt; simdjson::fallback::ondemand::value::get_string </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_replacement</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to a string.</p>
<p>The string is guaranteed to be valid UTF-8.</p>
<p>Equivalent to <a class="el" href="#a516642be78954f52fbaa83886194f2e8">get&lt;std::string_view&gt;()</a>.</p>
<p>Important: a value should be consumed once. Calling <a class="el" href="#aedc9e0e40f4a23cb182c55def0134f29">get_string()</a> twice on the same value is an error.</p>
<dl class="section return"><dt>Returns</dt><dd>An UTF-8 string. The string is stored in the parser and will be invalidated the next time it parses a document or when it is destroyed. </dd>
<dd>
INCORRECT_TYPE if the JSON value is not a string. </dd></dl>

</div>
</div>
<a id="a1f083c1216e10bec543e50a103aab82f" name="a1f083c1216e10bec543e50a103aab82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f083c1216e10bec543e50a103aab82f">&#9670;&#160;</a></span>get_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename string_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a> simdjson::fallback::ondemand::value::get_string </td>
          <td>(</td>
          <td class="paramtype">string_type &amp;</td>          <td class="paramname"><span class="paramname"><em>receiver</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_replacement</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to fill the provided std::string reference with the parsed value of the current string.</p>
<p>The string is guaranteed to be valid UTF-8.</p>
<p>Important: a value should be consumed once. Calling <a class="el" href="#aedc9e0e40f4a23cb182c55def0134f29">get_string()</a> twice on the same value is an error.</p>
<p>Performance: This method may be slower than <a class="el" href="#aedc9e0e40f4a23cb182c55def0134f29">get_string()</a> or <a class="el" href="#aedc9e0e40f4a23cb182c55def0134f29">get_string(bool)</a> because it may need to allocate memory. We recommend you avoid allocating an std::string unless you need to.</p>
<dl class="section return"><dt>Returns</dt><dd>INCORRECT_TYPE if the JSON value is not a string. Otherwise, we return SUCCESS. </dd></dl>

</div>
</div>
<a id="ac2907e78cac3696db71b926c8de10f95" name="ac2907e78cac3696db71b926c8de10f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2907e78cac3696db71b926c8de10f95">&#9670;&#160;</a></span>get_uint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; uint64_t &gt; simdjson::fallback::ondemand::value::get_uint64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to an unsigned integer.</p>
<dl class="section return"><dt>Returns</dt><dd>A unsigned 64-bit integer. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer. </dd></dl>

</div>
</div>
<a id="a772fedc13be084ebc9f5861873772643" name="a772fedc13be084ebc9f5861873772643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772fedc13be084ebc9f5861873772643">&#9670;&#160;</a></span>get_uint64_in_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; uint64_t &gt; simdjson::fallback::ondemand::value::get_uint64_in_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value (inside string) to a unsigned integer.</p>
<dl class="section return"><dt>Returns</dt><dd>A unsigned 64-bit integer. </dd>
<dd>
INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer. </dd></dl>

</div>
</div>
<a id="ae1e395bdb28c394d87fe872f7aa7f543" name="ae1e395bdb28c394d87fe872f7aa7f543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e395bdb28c394d87fe872f7aa7f543">&#9670;&#160;</a></span>get_wobbly_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt; simdjson::fallback::ondemand::value::get_wobbly_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast this JSON value to a "wobbly" string.</p>
<p>The string is may not be a valid UTF-8 string. See <a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
<p>Important: a value should be consumed once. Calling <a class="el" href="#ae1e395bdb28c394d87fe872f7aa7f543">get_wobbly_string()</a> twice on the same value is an error.</p>
<dl class="section return"><dt>Returns</dt><dd>An UTF-8 string. The string is stored in the parser and will be invalidated the next time it parses a document or when it is destroyed. </dd>
<dd>
INCORRECT_TYPE if the JSON value is not a string. </dd></dl>

</div>
</div>
<a id="a783689de68b6209fdb0605b972e63dd2" name="a783689de68b6209fdb0605b972e63dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783689de68b6209fdb0605b972e63dd2">&#9670;&#160;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::value::is_integer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the value is an integer number. Note that this requires to partially parse the number string. If the value is determined to be an integer, it may still not parse properly as an integer in subsequent steps (e.g., it might overflow).</p>
<p>Performance note: if you call this function systematically before parsing a number, you may have fallen for a performance anti-pattern.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the number if negative. </dd></dl>

</div>
</div>
<a id="a692c957af2128212cdb802b2b4336e70" name="a692c957af2128212cdb802b2b4336e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c957af2128212cdb802b2b4336e70">&#9670;&#160;</a></span>is_negative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline bool simdjson::fallback::ondemand::value::is_negative </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the value is a negative number.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the number if negative. </dd></dl>

</div>
</div>
<a id="a3b1aa1a5d7c66f2ed88b959fe35173c0" name="a3b1aa1a5d7c66f2ed88b959fe35173c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1aa1a5d7c66f2ed88b959fe35173c0">&#9670;&#160;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::value::is_null </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if this JSON value is null. If and only if the value is null, then it is consumed (we advance). If we find a token that begins with 'n' but is not 'null', then an error is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the value is null. </dd>
<dd>
INCORRECT_TYPE If the JSON value begins with 'n' and is not 'null'. </dd></dl>

</div>
</div>
<a id="a0e85700ea22dd94b6d5fe290cbb58ced" name="a0e85700ea22dd94b6d5fe290cbb58ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e85700ea22dd94b6d5fe290cbb58ced">&#9670;&#160;</a></span>is_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::value::is_scalar </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the value is a scalar (string, number, null, Boolean). Returns false when there it is an array or object.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the type is string, number, null, Boolean @error TAPE_ERROR when the JSON value is a bad token like "}" "," or "alse". </dd></dl>

</div>
</div>
<a id="a1d85d6edcbf5d273153af35618a1ddc9" name="a1d85d6edcbf5d273153af35618a1ddc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d85d6edcbf5d273153af35618a1ddc9">&#9670;&#160;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::value::is_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the value is a string.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the type is string @error TAPE_ERROR when the JSON value is a bad token like "}" "," or "alse". </dd></dl>

</div>
</div>
<a id="a1a5a435df727ef09398d56a848674818" name="a1a5a435df727ef09398d56a848674818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5a435df727ef09398d56a848674818">&#9670;&#160;</a></span>raw_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt; simdjson::fallback::ondemand::value::raw_json </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a string_view pointing at this value in the JSON document. If this element is an array or an object, it consumes the array or the object and returns a string_view instance corresponding to the array as represented in JSON. It points inside the original document. If this element is a scalar (string, number, Boolean, null), it returns what <a class="el" href="#a5646f492ee8e480e4bb210b14cf5124f">raw_json_token()</a> would return. </p>

</div>
</div>
<a id="a5646f492ee8e480e4bb210b14cf5124f" name="a5646f492ee8e480e4bb210b14cf5124f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5646f492ee8e480e4bb210b14cf5124f">&#9670;&#160;</a></span>raw_json_token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline std::string_view simdjson::fallback::ondemand::value::raw_json_token </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the raw JSON for this token.</p>
<p>The string_view will always point into the input buffer.</p>
<p>The string_view will start at the beginning of the token, and include the entire token <em>as well as all spaces until the next token (or EOF).</em> This means, for example, that a string token always begins with a " and is always terminated by the final ", possibly followed by a number of spaces.</p>
<p>The string_view is <em>not</em> null-terminated. However, if this is a scalar (string, number, boolean, or null), the character after the end of the string_view is guaranteed to be a non-space token.</p>
<p>Tokens include:</p><ul>
<li>{</li>
<li>[</li>
<li>"a string (possibly with UTF-8 or backslashed characters like \\\")".</li>
<li>-1.2e-100</li>
<li>true</li>
<li>false</li>
<li>null</li>
</ul>
<p>See also <a class="el" href="#a1a5a435df727ef09398d56a848674818">value::raw_json()</a>. </p>

</div>
</div>
<a id="a65fdf8190a2baec7150c28e48bd262b1" name="a65fdf8190a2baec7150c28e48bd262b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fdf8190a2baec7150c28e48bd262b1">&#9670;&#160;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> simdjson::fallback::ondemand::value::resume </td>
          <td>(</td>
          <td class="paramtype">const value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resume a value. </p>

</div>
</div>
<a id="a89745bb8e4dca4427d5928989cda2914" name="a89745bb8e4dca4427d5928989cda2914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89745bb8e4dca4427d5928989cda2914">&#9670;&#160;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline void simdjson::fallback::ondemand::value::skip </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip this value, allowing iteration to continue. </p>

</div>
</div>
<a id="a50b49989393da6777ea6bace184470d0" name="a50b49989393da6777ea6bace184470d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b49989393da6777ea6bace184470d0">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> simdjson::fallback::ondemand::value::start </td>
          <td>(</td>
          <td class="paramtype">const value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a value at the current position.</p>
<p>(It should already be started; this is just a self-documentation method.) </p>

</div>
</div>
<a id="aaee5e148acc7524b2864c2c0ca96893a" name="aaee5e148acc7524b2864c2c0ca96893a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee5e148acc7524b2864c2c0ca96893a">&#9670;&#160;</a></span>start_or_resume_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt; simdjson::fallback::ondemand::value::start_or_resume_object </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the object, starting or resuming it as necessary </p>

</div>
</div>
<a id="a871bd06caa8f3a24329716f193a83f88" name="a871bd06caa8f3a24329716f193a83f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871bd06caa8f3a24329716f193a83f88">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037e">json_type</a> &gt; simdjson::fallback::ondemand::value::type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the type of this JSON value. It does not validate or consume the value. E.g., you must still call "is_null()" to check that a value is null even if "type()" returns <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037ea37a6259cc0c1dae299a7866489dff0bd" title="A JSON null (null)">json_type::null</a>.</p>
<p>NOTE: If you're only expecting a value to be one type (a typical case), it's generally better to just call .get_double, .get_string, etc. and check for INCORRECT_TYPE (or just let it throw an exception).</p>
<dl class="section return"><dt>Returns</dt><dd>The type of JSON value (<a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037eaf1f713c9e000f5d3f280adbd124df4f5" title="A JSON array ( [ 1, 2, 3 ... ] )">json_type::array</a>, <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037eaa8cfde6331bd59eb2ac96f8911c4b666" title="A JSON object ( { &quot;a&quot;: 1, &quot;b&quot; 2, ... } )">json_type::object</a>, <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037eab45cffe084dd3d20d928bee85e7b0f21" title="A JSON string ( &quot;a&quot; or &quot;hello world\n&quot; ...)">json_type::string</a>, <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037eab1bc248a7ff2b2e95569f56de68615df" title="A JSON number ( 1 or -2.3 or 4.5e6 ...)">json_type::number</a>, <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037ea84e2c64f38f78ba3ea5c905ab5a2da27" title="A JSON boolean (true or false)">json_type::boolean</a>, or <a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html#a7bba3f8bd6a47296ce919513ed4d037ea37a6259cc0c1dae299a7866489dff0bd" title="A JSON null (null)">json_type::null</a>). @error TAPE_ERROR when the JSON value is a bad token like "}" "," or "alse". </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/corpus-cleaner/corpus_cleaner/<a class="el" href="simdjson_8h_source.html">simdjson.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
