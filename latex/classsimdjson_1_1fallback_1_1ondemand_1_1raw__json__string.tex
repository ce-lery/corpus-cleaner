\doxysection{simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string Class Reference}
\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}


{\ttfamily \#include $<$simdjson.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aac1a3c29fa68e6944c186bd7fe6f145d}{raw\+\_\+json\+\_\+string}} () noexcept=default
\item 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aacb74fe795e77900d5165011f5f70989}{raw\+\_\+json\+\_\+string}} (const uint8\+\_\+t \texorpdfstring{$\ast$}{*}\+\_\+buf) noexcept
\item 
simdjson\+\_\+inline const char \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_ac5b5111d02234e84c49435005fe0c42b}{raw}} () const noexcept
\item 
simdjson\+\_\+inline bool \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aa9394243757959ebe046eb0caf14fa5b}{unsafe\+\_\+is\+\_\+equal}} (size\+\_\+t length, std\+::string\+\_\+view target) const noexcept
\item 
simdjson\+\_\+inline bool \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a0429f9ef3cc83ff30a3b24d534f3c756}{unsafe\+\_\+is\+\_\+equal}} (std\+::string\+\_\+view target) const noexcept
\item 
simdjson\+\_\+inline bool \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a98bab2a3eb6b18443d65252a45e9fc50}{unsafe\+\_\+is\+\_\+equal}} (const char \texorpdfstring{$\ast$}{*}target) const noexcept
\item 
simdjson\+\_\+inline bool \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aa1651dc03a97270fb127ba6081804a61}{is\+\_\+equal}} (std\+::string\+\_\+view target) const noexcept
\item 
simdjson\+\_\+inline bool \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_ab26899e488a66c26ae8034df6b9c4ee2}{is\+\_\+equal}} (const char \texorpdfstring{$\ast$}{*}target) const noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static simdjson\+\_\+inline bool \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a82e0d42432a70cdf261d2b5eea1f10bf}{is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote}} (std\+::string\+\_\+view target) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a83cd125de860d89bd0cc3cf96c1f3efd}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a83cd125de860d89bd0cc3cf96c1f3efd} 
static simdjson\+\_\+inline bool {\bfseries is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote} (const char \texorpdfstring{$\ast$}{*}target) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a3d4dcacb8171b99f783396bb6a337c65}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a3d4dcacb8171b99f783396bb6a337c65} 
class {\bfseries object}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_acd53905ae10cba58b4337aefe648aec6}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_acd53905ae10cba58b4337aefe648aec6} 
class {\bfseries field}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a8de78aa991dff0fc519d5c721ea49733}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a8de78aa991dff0fc519d5c721ea49733} 
class {\bfseries parser}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aab1989049cf0c8cd84839c50da1f3de4}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aab1989049cf0c8cd84839c50da1f3de4} 
struct {\bfseries simdjson\+\_\+result$<$ raw\+\_\+json\+\_\+string $>$}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A string escaped per JSON rules, terminated with quote ("{}). They are used to represent unescaped keys inside JSON documents.

(In other words, a pointer to the beginning of a string, just after the start quote, inside a JSON file.)

This class is deliberately simplistic and has little functionality. You can compare a \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instance with an unescaped C string, but that is nearly all you can do.

The \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} is unescaped. If you wish to write an unescaped version of it to your own buffer, you may do so using the parser.\+unescape(string, buff) method, using an \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{ondemand\+::parser} instance. Doing so requires you to have a sufficiently large buffer.

The \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instances originate typically from field instance which in turn represent key-\/value pairs from object instances. From a field instance, you get the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instance by calling key(). You can, if you want a more usable string\+\_\+view instance, call the unescaped\+\_\+key() method on the field instance. You may also create a \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} from any other string value, with the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1value_a459513c4f6d9c013b7d65e17ebe0e56f}{value.\+get\+\_\+raw\+\_\+json\+\_\+string()} method. Again, you can get a more usable string\+\_\+view instance by calling get\+\_\+string(). 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aac1a3c29fa68e6944c186bd7fe6f145d}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aac1a3c29fa68e6944c186bd7fe6f145d} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!raw\_json\_string@{raw\_json\_string}}
\index{raw\_json\_string@{raw\_json\_string}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{raw\_json\_string()}{raw\_json\_string()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::raw\+\_\+json\+\_\+string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Create a new invalid \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}.

Exists so you can declare a variable and later assign to it before use. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aacb74fe795e77900d5165011f5f70989}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aacb74fe795e77900d5165011f5f70989} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!raw\_json\_string@{raw\_json\_string}}
\index{raw\_json\_string@{raw\_json\_string}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{raw\_json\_string()}{raw\_json\_string()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::raw\+\_\+json\+\_\+string (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t \texorpdfstring{$\ast$}{*}}]{\+\_\+buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Create a new invalid \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} pointed at the given location in the JSON.

The given location must be just {\itshape after} the beginning quote ("{}) in the JSON file.  \+It $<$em$>$must$<$/em$>$ be terminated by a "{}, and be a valid JSON string. 

\doxysubsection{Member Function Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_ab26899e488a66c26ae8034df6b9c4ee2}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_ab26899e488a66c26ae8034df6b9c4ee2} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!is\_equal@{is\_equal}}
\index{is\_equal@{is\_equal}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{is\_equal()}{is\_equal()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily simdjson\+\_\+inline bool simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::is\+\_\+equal (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{target }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

This compares the current instance to the C string target\+: returns true if they are byte-\/by-\/byte equal (no escaping is done). \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aa1651dc03a97270fb127ba6081804a61}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aa1651dc03a97270fb127ba6081804a61} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!is\_equal@{is\_equal}}
\index{is\_equal@{is\_equal}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{is\_equal()}{is\_equal()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily simdjson\+\_\+inline bool simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::is\+\_\+equal (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{target }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

This compares the current instance to the std\+::string\+\_\+view target\+: returns true if they are byte-\/by-\/byte equal (no escaping is done). \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a82e0d42432a70cdf261d2b5eea1f10bf}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a82e0d42432a70cdf261d2b5eea1f10bf} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!is\_free\_from\_unescaped\_quote@{is\_free\_from\_unescaped\_quote}}
\index{is\_free\_from\_unescaped\_quote@{is\_free\_from\_unescaped\_quote}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{is\_free\_from\_unescaped\_quote()}{is\_free\_from\_unescaped\_quote()}}
{\footnotesize\ttfamily simdjson\+\_\+inline bool simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{target }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [noexcept]}}

Returns true if target is free from unescaped quote. If target is known at compile-\/time, we might expect the computation to happen at compile time with many compilers (not all!). \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_ac5b5111d02234e84c49435005fe0c42b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_ac5b5111d02234e84c49435005fe0c42b} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!raw@{raw}}
\index{raw@{raw}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{raw()}{raw()}}
{\footnotesize\ttfamily simdjson\+\_\+inline const char \texorpdfstring{$\ast$}{*} simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::raw (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Get the raw pointer to the beginning of the string in the JSON (just after the "{}).

It is possible for this function to return a null pointer if the instance has outlived its existence. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a98bab2a3eb6b18443d65252a45e9fc50}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a98bab2a3eb6b18443d65252a45e9fc50} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!unsafe\_is\_equal@{unsafe\_is\_equal}}
\index{unsafe\_is\_equal@{unsafe\_is\_equal}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{unsafe\_is\_equal()}{unsafe\_is\_equal()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily simdjson\+\_\+inline bool simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::unsafe\+\_\+is\+\_\+equal (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{target }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

This compares the current instance to the C string target\+: returns true if they are byte-\/by-\/byte equal (no escaping is done). The provided C string should not contain an unescaped quote character\+: the caller is responsible for this check. See is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote.

If target is a compile-\/time constant, and your compiler likes you, you should be able to do the following without performance penalty...

static\+\_\+assert(raw\+\_\+json\+\_\+string\+::is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote(target), "{}"{}); s.\+unsafe\+\_\+is\+\_\+equal(target); \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aa9394243757959ebe046eb0caf14fa5b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_aa9394243757959ebe046eb0caf14fa5b} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!unsafe\_is\_equal@{unsafe\_is\_equal}}
\index{unsafe\_is\_equal@{unsafe\_is\_equal}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{unsafe\_is\_equal()}{unsafe\_is\_equal()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily simdjson\+\_\+inline bool simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::unsafe\+\_\+is\+\_\+equal (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{length,  }\item[{std\+::string\+\_\+view}]{target }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

This compares the current instance to the std\+::string\+\_\+view target\+: returns true if they are byte-\/by-\/byte equal (no escaping is done) on target.\+size() characters, and if the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instance has a quote character at byte index target.\+size(). We never read more than length + 1 bytes in the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instance. If length is smaller than target.\+size(), this will return false.

The std\+::string\+\_\+view instance may contain any characters. However, the caller is responsible for setting length so that length bytes may be read in the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}.

Performance\+: the comparison may be done using memcmp which may be efficient for long strings. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a0429f9ef3cc83ff30a3b24d534f3c756}\label{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string_a0429f9ef3cc83ff30a3b24d534f3c756} 
\index{simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}!unsafe\_is\_equal@{unsafe\_is\_equal}}
\index{unsafe\_is\_equal@{unsafe\_is\_equal}!simdjson::fallback::ondemand::raw\_json\_string@{simdjson::fallback::ondemand::raw\_json\_string}}
\doxysubsubsection{\texorpdfstring{unsafe\_is\_equal()}{unsafe\_is\_equal()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily simdjson\+\_\+inline bool simdjson\+::fallback\+::ondemand\+::raw\+\_\+json\+\_\+string\+::unsafe\+\_\+is\+\_\+equal (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{target }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

This compares the current instance to the std\+::string\+\_\+view target\+: returns true if they are byte-\/by-\/byte equal (no escaping is done). The std\+::string\+\_\+view instance should not contain unescaped quote characters\+: the caller is responsible for this check. See is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote.

Performance\+: the comparison is done byte-\/by-\/byte which might be inefficient for long strings.

If target is a compile-\/time constant, and your compiler likes you, you should be able to do the following without performance penalty...

static\+\_\+assert(raw\+\_\+json\+\_\+string\+::is\+\_\+free\+\_\+from\+\_\+unescaped\+\_\+quote(target), "{}"{}); s.\+unsafe\+\_\+is\+\_\+equal(target); 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/corpus-\/cleaner/corpus\+\_\+cleaner/simdjson.\+h\end{DoxyCompactItemize}
