\doxysection{simdjson\+::fallback\+::ondemand\+::array Class Reference}
\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array}{}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array}\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}


{\ttfamily \#include $<$simdjson.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a2162eb035821904cffdb88eb45101ef9}{array}} () noexcept=default
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator}{array\+\_\+iterator}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a25f7cdad37f6fc03e6813c1e5241de7a}{begin}} () noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator}{array\+\_\+iterator}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7857ade11d19f0246981a3bfede2aa55}{end}} () noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ size\+\_\+t $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_aab5599414f1da1fb7f7af557d9f130e2}{count\+\_\+elements}} () \&noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_af336be8412b0c62e531c7c01b93f381b}{is\+\_\+empty}} () \&noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a46c2aaff0d7a7353e0c591575c2e856a}{reset}} () \&noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a74563b006045cb457e26a1346785dfa8}{at\+\_\+pointer}} (std\+::string\+\_\+view json\+\_\+pointer) noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_af7007d938d27d6958af72e5ec6c7db00}{at\+\_\+path}} (std\+::string\+\_\+view json\+\_\+path) noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_ad331fe16347deb29a4e86ea25d9ea593}{raw\+\_\+json}} () noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a6754945c3dbaeb162b195db718339ba1}{at}} (size\+\_\+t index) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a99c7c58610ab175b80ab1c4cae2a5a7f}{consume}} () noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_ade71d1510b414a9f45d01c3fb531b314}{array}} (const value\+\_\+iterator \&\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877}{iter}}) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array}{array}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a8e9d63c5e907ccc2b451f477f787d37f}{start}} (value\+\_\+iterator \&\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877}{iter}}) noexcept
\item 
static simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array}{array}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_ac2b41f525131aadc305f5d73aecb6205}{start\+\_\+root}} (value\+\_\+iterator \&\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877}{iter}}) noexcept
\item 
static simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array}{array}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7ccb9851cf460ade98cbe332f5e0d405}{started}} (value\+\_\+iterator \&\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877}{iter}}) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
value\+\_\+iterator \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877}{iter}} \{\}
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_ae5cda98fa74051d037c0c444c67efb15}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_ae5cda98fa74051d037c0c444c67efb15} 
class {\bfseries value}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7c20332b4481f29ace969e40cfce5f5f}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7c20332b4481f29ace969e40cfce5f5f} 
class {\bfseries document}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a9ad87deba0e08e8188b26485164889fb}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a9ad87deba0e08e8188b26485164889fb} 
struct {\bfseries simdjson\+\_\+result$<$ value $>$}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_ad294ba09879c3b42b87298bbc334439b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_ad294ba09879c3b42b87298bbc334439b} 
struct {\bfseries simdjson\+\_\+result$<$ array $>$}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_aec7be9f74f64c08fae57eaf36044f7a9}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_aec7be9f74f64c08fae57eaf36044f7a9} 
class {\bfseries array\+\_\+iterator}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A forward-\/only JSON array. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a2162eb035821904cffdb88eb45101ef9}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a2162eb035821904cffdb88eb45101ef9} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!array@{array}}
\index{array@{array}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{array()}{array()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+::fallback\+::ondemand\+::array\+::array (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Create a new invalid array.

Exists so you can declare a variable and later assign to it before use. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_ade71d1510b414a9f45d01c3fb531b314}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_ade71d1510b414a9f45d01c3fb531b314} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!array@{array}}
\index{array@{array}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{array()}{array()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+::fallback\+::ondemand\+::array\+::array (\begin{DoxyParamCaption}\item[{const value\+\_\+iterator \&}]{iter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [noexcept]}}

Create an array at the given Internal array creation. Call \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a8e9d63c5e907ccc2b451f477f787d37f}{array\+::start()} or \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7ccb9851cf460ade98cbe332f5e0d405}{array\+::started()} instead of this.


\begin{DoxyParams}{Parameters}
{\em iter} & The iterator. Must either be at the start of the first element with iter.\+is\+\_\+alive() == true, or past the \mbox{[}\mbox{]} with is\+\_\+alive() == false if the array is empty. Will be {\itshape moved} into the resulting array. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a6754945c3dbaeb162b195db718339ba1}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a6754945c3dbaeb162b195db718339ba1} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!at@{at}}
\index{at@{at}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{at()}{at()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::at (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Get the value at the given index. This function has linear-\/time complexity. This function should only be called once on an array instance since the array iterator is not reset between each call.

\begin{DoxyReturn}{Returns}
The value at the given index, or\+:
\begin{DoxyItemize}
\item INDEX\+\_\+\+OUT\+\_\+\+OF\+\_\+\+BOUNDS if the array index is larger than an array length 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_af7007d938d27d6958af72e5ec6c7db00}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_af7007d938d27d6958af72e5ec6c7db00} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!at\_path@{at\_path}}
\index{at\_path@{at\_path}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{at\_path()}{at\_path()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::at\+\_\+path (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{json\+\_\+path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get the value associated with the given JSONPath expression. We only support JSONPath queries that trivially convertible to JSON Pointer queries\+: key names and array indices.

\href{https://datatracker.ietf.org/doc/html/draft-normington-jsonpath-00}{\texttt{ https\+://datatracker.\+ietf.\+org/doc/html/draft-\/normington-\/jsonpath-\/00}}

\begin{DoxyReturn}{Returns}
The value associated with the given JSONPath expression, or\+:
\begin{DoxyItemize}
\item INVALID\+\_\+\+JSON\+\_\+\+POINTER if the JSONPath to JSON Pointer conversion fails
\item NO\+\_\+\+SUCH\+\_\+\+FIELD if a field does not exist in an object
\item INDEX\+\_\+\+OUT\+\_\+\+OF\+\_\+\+BOUNDS if an array index is larger than an array length
\item INCORRECT\+\_\+\+TYPE if a non-\/integer is used to access an array 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a74563b006045cb457e26a1346785dfa8}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a74563b006045cb457e26a1346785dfa8} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!at\_pointer@{at\_pointer}}
\index{at\_pointer@{at\_pointer}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{at\_pointer()}{at\_pointer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::at\+\_\+pointer (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{json\+\_\+pointer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get the value associated with the given JSON pointer. We use the RFC 6901 \href{https://tools.ietf.org/html/rfc6901}{\texttt{ https\+://tools.\+ietf.\+org/html/rfc6901}} standard, interpreting the current node as the root of its own JSON document.

\doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{ondemand\+::parser} parser; auto json = R"{}(\mbox{[} \{ "{}foo"{}\+: \{ "{}a"{}\+: \mbox{[} 10, 20, 30 \mbox{]} \}\} \mbox{]})"{}\+\_\+padded; auto doc = parser.\+iterate(json); doc.\+at\+\_\+pointer("{}/0/foo/a/1"{}) == 20

Note that \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a74563b006045cb457e26a1346785dfa8}{at\+\_\+pointer()} called on the document automatically calls the document\textquotesingle{}s rewind method between each call. It invalidates all previously accessed arrays, objects and values that have not been consumed. Yet it is not the case when calling at\+\_\+pointer on an array instance\+: there is no rewind and no invalidation.

You may only call at\+\_\+pointer on an array after it has been created, but before it has been first accessed. When calling at\+\_\+pointer on an array, the pointer is advanced to the location indicated by the JSON pointer (in case of success). It is no longer possible to call at\+\_\+pointer on the same array.

Also note that \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1array_a74563b006045cb457e26a1346785dfa8}{at\+\_\+pointer()} relies on find\+\_\+field() which implies that we do not unescape keys when matching.

\begin{DoxyReturn}{Returns}
The value associated with the given JSON pointer, or\+:
\begin{DoxyItemize}
\item NO\+\_\+\+SUCH\+\_\+\+FIELD if a field does not exist in an object
\item INDEX\+\_\+\+OUT\+\_\+\+OF\+\_\+\+BOUNDS if an array index is larger than an array length
\item INCORRECT\+\_\+\+TYPE if a non-\/integer is used to access an array
\item INVALID\+\_\+\+JSON\+\_\+\+POINTER if the JSON pointer is invalid and cannot be parsed 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a25f7cdad37f6fc03e6813c1e5241de7a}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a25f7cdad37f6fc03e6813c1e5241de7a} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!begin@{begin}}
\index{begin@{begin}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{begin()}{begin()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator}{array\+\_\+iterator}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::begin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Begin array iteration.

Part of the std\+::iterable interface. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a99c7c58610ab175b80ab1c4cae2a5a7f}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a99c7c58610ab175b80ab1c4cae2a5a7f} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!consume@{consume}}
\index{consume@{consume}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{consume()}{consume()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} simdjson\+::fallback\+::ondemand\+::array\+::consume (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [noexcept]}}

Go to the end of the array, no matter where you are right now. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_aab5599414f1da1fb7f7af557d9f130e2}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_aab5599414f1da1fb7f7af557d9f130e2} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!count\_elements@{count\_elements}}
\index{count\_elements@{count\_elements}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{count\_elements()}{count\_elements()}}
{\footnotesize\ttfamily SIMDJSON\+\_\+\+PUSH\+\_\+\+DISABLE\+\_\+\+WARNINGS SIMDJSON\+\_\+\+DISABLE\+\_\+\+STRICT\+\_\+\+OVERFLOW\+\_\+\+WARNING simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ size\+\_\+t $>$ simdjson\+::fallback\+::ondemand\+::array\+::count\+\_\+elements (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [noexcept]}}

This method scans the array and counts the number of elements. The count\+\_\+elements method should always be called before you have begun iterating through the array\+: it is expected that you are pointing at the beginning of the array. The runtime complexity is linear in the size of the array. After calling this function, if successful, the array is \textquotesingle{}rewinded\textquotesingle{} at its beginning as if it had never been accessed. If the JSON is malformed (e.\+g., there is a missing comma), then an error is returned and it is no longer safe to continue.

To check that an array is empty, it is more performant to use the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1array_af336be8412b0c62e531c7c01b93f381b}{is\+\_\+empty()} method. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7857ade11d19f0246981a3bfede2aa55}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7857ade11d19f0246981a3bfede2aa55} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!end@{end}}
\index{end@{end}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{end()}{end()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator}{array\+\_\+iterator}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Sentinel representing the end of the array.

Part of the std\+::iterable interface. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_af336be8412b0c62e531c7c01b93f381b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_af336be8412b0c62e531c7c01b93f381b} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!is\_empty@{is\_empty}}
\index{is\_empty@{is\_empty}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{is\_empty()}{is\_empty()}}
{\footnotesize\ttfamily SIMDJSON\+\_\+\+POP\+\_\+\+DISABLE\+\_\+\+WARNINGS simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::array\+::is\+\_\+empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [noexcept]}}

This method scans the beginning of the array and checks whether the array is empty. The runtime complexity is constant time. After calling this function, if successful, the array is \textquotesingle{}rewinded\textquotesingle{} at its beginning as if it had never been accessed. If the JSON is malformed (e.\+g., there is a missing comma), then an error is returned and it is no longer safe to continue. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_ad331fe16347deb29a4e86ea25d9ea593}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_ad331fe16347deb29a4e86ea25d9ea593} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!raw\_json@{raw\_json}}
\index{raw\_json@{raw\_json}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{raw\_json()}{raw\_json()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ simdjson\+::fallback\+::ondemand\+::array\+::raw\+\_\+json (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Consumes the array and returns a string\+\_\+view instance corresponding to the array as represented in JSON. It points inside the original document. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a46c2aaff0d7a7353e0c591575c2e856a}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a46c2aaff0d7a7353e0c591575c2e856a} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!reset@{reset}}
\index{reset@{reset}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::array\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Reset the iterator so that we are pointing back at the beginning of the array. You should still consume values only once even if you can iterate through the array more than once. If you unescape a string within the array more than once, you have unsafe code. Note that rewinding an array means that you may need to reparse it anew\+: it is not a free operation.

\begin{DoxyReturn}{Returns}
true if the array contains some elements (not empty) 
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a8e9d63c5e907ccc2b451f477f787d37f}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a8e9d63c5e907ccc2b451f477f787d37f} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!start@{start}}
\index{start@{start}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{start()}{start()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array}{array}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::start (\begin{DoxyParamCaption}\item[{value\+\_\+iterator \&}]{iter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}

Begin array iteration.


\begin{DoxyParams}{Parameters}
{\em iter} & The iterator. Must be where the initial \mbox{[} is expected. Will be {\itshape moved} into the resulting array. @error INCORRECT\+\_\+\+TYPE if the iterator is not at \mbox{[}. \\
\hline
\end{DoxyParams}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_ac2b41f525131aadc305f5d73aecb6205}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_ac2b41f525131aadc305f5d73aecb6205} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!start\_root@{start\_root}}
\index{start\_root@{start\_root}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{start\_root()}{start\_root()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array}{array}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::start\+\_\+root (\begin{DoxyParamCaption}\item[{value\+\_\+iterator \&}]{iter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}

Begin array iteration from the root.


\begin{DoxyParams}{Parameters}
{\em iter} & The iterator. Must be where the initial \mbox{[} is expected. Will be {\itshape moved} into the resulting array. @error INCORRECT\+\_\+\+TYPE if the iterator is not at \mbox{[}. @error TAPE\+\_\+\+ERROR if there is no closing \mbox{]} at the end of the document. \\
\hline
\end{DoxyParams}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7ccb9851cf460ade98cbe332f5e0d405}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a7ccb9851cf460ade98cbe332f5e0d405} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!started@{started}}
\index{started@{started}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{started()}{started()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1array}{array}} $>$ simdjson\+::fallback\+::ondemand\+::array\+::started (\begin{DoxyParamCaption}\item[{value\+\_\+iterator \&}]{iter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}

Begin array iteration.

This version of the method should be called after the initial \mbox{[} has been verified, and is intended for use by switch statements that check the type of a value.


\begin{DoxyParams}{Parameters}
{\em iter} & The iterator. Must be after the initial \mbox{[}. Will be {\itshape moved} into the resulting array. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Data Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877}\label{classsimdjson_1_1fallback_1_1ondemand_1_1array_a831dbe58aef8d6c97b740f4763a48877} 
\index{simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}!iter@{iter}}
\index{iter@{iter}!simdjson::fallback::ondemand::array@{simdjson::fallback::ondemand::array}}
\doxysubsubsection{\texorpdfstring{iter}{iter}}
{\footnotesize\ttfamily value\+\_\+iterator simdjson\+::fallback\+::ondemand\+::array\+::iter \{\}\hspace{0.3cm}{\ttfamily [protected]}}

Iterator marking current position.

iter.\+is\+\_\+alive() == false indicates iteration is complete. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/corpus-\/cleaner/corpus\+\_\+cleaner/simdjson.\+h\end{DoxyCompactItemize}
