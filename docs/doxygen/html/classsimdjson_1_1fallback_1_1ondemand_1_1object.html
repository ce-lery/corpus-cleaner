<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Corpus Cleaner: simdjson::fallback::ondemand::object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Corpus Cleaner
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesimdjson.html">simdjson</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1fallback.html">fallback</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html">ondemand</a></li><li class="navelem"><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsimdjson_1_1fallback_1_1ondemand_1_1object-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simdjson::fallback::ondemand::object Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="simdjson_8h_source.html">simdjson.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a11782810fac89fc282535e42d25bab56" id="r_a11782810fac89fc282535e42d25bab56"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11782810fac89fc282535e42d25bab56">object</a> () noexcept=default</td></tr>
<tr class="separator:a11782810fac89fc282535e42d25bab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad405e01b709aa94c3104a55b5f00511a" id="r_ad405e01b709aa94c3104a55b5f00511a"><td class="memItemLeft" align="right" valign="top"><a id="ad405e01b709aa94c3104a55b5f00511a" name="ad405e01b709aa94c3104a55b5f00511a"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object__iterator.html">object_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:ad405e01b709aa94c3104a55b5f00511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cca970cfdca2d210902c301f1c9b662" id="r_a4cca970cfdca2d210902c301f1c9b662"><td class="memItemLeft" align="right" valign="top"><a id="a4cca970cfdca2d210902c301f1c9b662" name="a4cca970cfdca2d210902c301f1c9b662"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object__iterator.html">object_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a4cca970cfdca2d210902c301f1c9b662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bd93c4ad188370f08e83239d1f6843" id="r_a56bd93c4ad188370f08e83239d1f6843"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56bd93c4ad188370f08e83239d1f6843">find_field</a> (std::string_view key) &amp;noexcept</td></tr>
<tr class="separator:a56bd93c4ad188370f08e83239d1f6843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e2bff7e74345727ca8bc081f505f7b" id="r_a92e2bff7e74345727ca8bc081f505f7b"><td class="memItemLeft" align="right" valign="top"><a id="a92e2bff7e74345727ca8bc081f505f7b" name="a92e2bff7e74345727ca8bc081f505f7b"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_field</b> (std::string_view key) &amp;&amp;noexcept</td></tr>
<tr class="separator:a92e2bff7e74345727ca8bc081f505f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1290092ed5d9cf8c80ec3d9811dd2b" id="r_a3a1290092ed5d9cf8c80ec3d9811dd2b"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a1290092ed5d9cf8c80ec3d9811dd2b">find_field_unordered</a> (std::string_view key) &amp;noexcept</td></tr>
<tr class="separator:a3a1290092ed5d9cf8c80ec3d9811dd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62d1c4096ba842ddcb6b9c644e6c0ae" id="r_aa62d1c4096ba842ddcb6b9c644e6c0ae"><td class="memItemLeft" align="right" valign="top"><a id="aa62d1c4096ba842ddcb6b9c644e6c0ae" name="aa62d1c4096ba842ddcb6b9c644e6c0ae"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_unordered</b> (std::string_view key) &amp;&amp;noexcept</td></tr>
<tr class="separator:aa62d1c4096ba842ddcb6b9c644e6c0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639aefc8292461d1ce5d2c5fbf52b2d9" id="r_a639aefc8292461d1ce5d2c5fbf52b2d9"><td class="memItemLeft" align="right" valign="top"><a id="a639aefc8292461d1ce5d2c5fbf52b2d9" name="a639aefc8292461d1ce5d2c5fbf52b2d9"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (std::string_view key) &amp;noexcept</td></tr>
<tr class="separator:a639aefc8292461d1ce5d2c5fbf52b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46d81067ab513d87572dd57f9f17d9" id="r_a3f46d81067ab513d87572dd57f9f17d9"><td class="memItemLeft" align="right" valign="top"><a id="a3f46d81067ab513d87572dd57f9f17d9" name="a3f46d81067ab513d87572dd57f9f17d9"></a>
simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (std::string_view key) &amp;&amp;noexcept</td></tr>
<tr class="separator:a3f46d81067ab513d87572dd57f9f17d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe7310eaf678a3fbe0935738bd5818" id="r_a9ebe7310eaf678a3fbe0935738bd5818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ebe7310eaf678a3fbe0935738bd5818">at_pointer</a> (std::string_view json_pointer) noexcept</td></tr>
<tr class="separator:a9ebe7310eaf678a3fbe0935738bd5818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156a49869fabb446d8501ae4e4f82c57" id="r_a156a49869fabb446d8501ae4e4f82c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a156a49869fabb446d8501ae4e4f82c57">at_path</a> (std::string_view json_path) noexcept</td></tr>
<tr class="separator:a156a49869fabb446d8501ae4e4f82c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fb23f375d581d1a664ca3cd9983b53" id="r_aa6fb23f375d581d1a664ca3cd9983b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6fb23f375d581d1a664ca3cd9983b53">reset</a> () &amp;noexcept</td></tr>
<tr class="separator:aa6fb23f375d581d1a664ca3cd9983b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b28b7377207fea100d882230f15897b" id="r_a8b28b7377207fea100d882230f15897b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b28b7377207fea100d882230f15897b">is_empty</a> () &amp;noexcept</td></tr>
<tr class="separator:a8b28b7377207fea100d882230f15897b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf0a05579330efd8e79e2255f336cd0" id="r_a3bf0a05579330efd8e79e2255f336cd0"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bf0a05579330efd8e79e2255f336cd0">count_fields</a> () &amp;noexcept</td></tr>
<tr class="separator:a3bf0a05579330efd8e79e2255f336cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294db4609b890ec94c1aeb44b3b2caea" id="r_a294db4609b890ec94c1aeb44b3b2caea"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a294db4609b890ec94c1aeb44b3b2caea">raw_json</a> () noexcept</td></tr>
<tr class="separator:a294db4609b890ec94c1aeb44b3b2caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed92810d20a93f72fbc168d2aca426a5" id="r_aed92810d20a93f72fbc168d2aca426a5"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed92810d20a93f72fbc168d2aca426a5">consume</a> () noexcept</td></tr>
<tr class="separator:aed92810d20a93f72fbc168d2aca426a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265486c6c2016848dfa0bdbafc6cec34" id="r_a265486c6c2016848dfa0bdbafc6cec34"><td class="memItemLeft" align="right" valign="top"><a id="a265486c6c2016848dfa0bdbafc6cec34" name="a265486c6c2016848dfa0bdbafc6cec34"></a>
simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><b>object</b> (const value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a265486c6c2016848dfa0bdbafc6cec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a32129c844fdf1e188e6fe65f240059" id="r_a4a32129c844fdf1e188e6fe65f240059"><td class="memItemLeft" align="right" valign="top"><a id="a4a32129c844fdf1e188e6fe65f240059" name="a4a32129c844fdf1e188e6fe65f240059"></a>
simdjson_warn_unused simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_raw</b> (const std::string_view key) noexcept</td></tr>
<tr class="separator:a4a32129c844fdf1e188e6fe65f240059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a5355de366d1b7ab670563e269b355c87" id="r_a5355de366d1b7ab670563e269b355c87"><td class="memItemLeft" align="right" valign="top"><a id="a5355de366d1b7ab670563e269b355c87" name="a5355de366d1b7ab670563e269b355c87"></a>
static simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>start</b> (value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a5355de366d1b7ab670563e269b355c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4983dc7d7b9d683b637e6cfeefa7ba49" id="r_a4983dc7d7b9d683b637e6cfeefa7ba49"><td class="memItemLeft" align="right" valign="top"><a id="a4983dc7d7b9d683b637e6cfeefa7ba49" name="a4983dc7d7b9d683b637e6cfeefa7ba49"></a>
static simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>start_root</b> (value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a4983dc7d7b9d683b637e6cfeefa7ba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868e9895c37ace90548d329a53ed5691" id="r_a868e9895c37ace90548d329a53ed5691"><td class="memItemLeft" align="right" valign="top"><a id="a868e9895c37ace90548d329a53ed5691" name="a868e9895c37ace90548d329a53ed5691"></a>
static simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>started</b> (value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a868e9895c37ace90548d329a53ed5691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c3ee00c788fd518e25d3e2641f8619" id="r_a59c3ee00c788fd518e25d3e2641f8619"><td class="memItemLeft" align="right" valign="top"><a id="a59c3ee00c788fd518e25d3e2641f8619" name="a59c3ee00c788fd518e25d3e2641f8619"></a>
static simdjson_inline <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>resume</b> (const value_iterator &amp;iter) noexcept</td></tr>
<tr class="separator:a59c3ee00c788fd518e25d3e2641f8619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac781adb849171481ec919ccbd06904ae" id="r_ac781adb849171481ec919ccbd06904ae"><td class="memItemLeft" align="right" valign="top"><a id="ac781adb849171481ec919ccbd06904ae" name="ac781adb849171481ec919ccbd06904ae"></a>
value_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iter</b> {}</td></tr>
<tr class="separator:ac781adb849171481ec919ccbd06904ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae5cda98fa74051d037c0c444c67efb15" id="r_ae5cda98fa74051d037c0c444c67efb15"><td class="memItemLeft" align="right" valign="top"><a id="ae5cda98fa74051d037c0c444c67efb15" name="ae5cda98fa74051d037c0c444c67efb15"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>value</b></td></tr>
<tr class="separator:ae5cda98fa74051d037c0c444c67efb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c20332b4481f29ace969e40cfce5f5f" id="r_a7c20332b4481f29ace969e40cfce5f5f"><td class="memItemLeft" align="right" valign="top"><a id="a7c20332b4481f29ace969e40cfce5f5f" name="a7c20332b4481f29ace969e40cfce5f5f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>document</b></td></tr>
<tr class="separator:a7c20332b4481f29ace969e40cfce5f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14649f261616070b04829c9ba6b28da" id="r_aa14649f261616070b04829c9ba6b28da"><td class="memItemLeft" align="right" valign="top"><a id="aa14649f261616070b04829c9ba6b28da" name="aa14649f261616070b04829c9ba6b28da"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>simdjson_result&lt; object &gt;</b></td></tr>
<tr class="separator:aa14649f261616070b04829c9ba6b28da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A forward-only JSON object field iterator. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a11782810fac89fc282535e42d25bab56" name="a11782810fac89fc282535e42d25bab56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11782810fac89fc282535e42d25bab56">&#9670;&#160;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::fallback::ondemand::object::object </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new invalid object.</p>
<p>Exists so you can declare a variable and later assign to it before use. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a156a49869fabb446d8501ae4e4f82c57" name="a156a49869fabb446d8501ae4e4f82c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156a49869fabb446d8501ae4e4f82c57">&#9670;&#160;</a></span>at_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::object::at_path </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>json_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value associated with the given JSONPath expression. We only support JSONPath queries that trivially convertible to JSON Pointer queries: key names and array indices.</p>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the given JSONPath expression, or:<ul>
<li>INVALID_JSON_POINTER if the JSONPath to JSON Pointer conversion fails</li>
<li>NO_SUCH_FIELD if a field does not exist in an object</li>
<li>INDEX_OUT_OF_BOUNDS if an array index is larger than an array length</li>
<li>INCORRECT_TYPE if a non-integer is used to access an array </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9ebe7310eaf678a3fbe0935738bd5818" name="a9ebe7310eaf678a3fbe0935738bd5818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebe7310eaf678a3fbe0935738bd5818">&#9670;&#160;</a></span>at_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::object::at_pointer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>json_pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value associated with the given JSON pointer. We use the RFC 6901 <a href="https://tools.ietf.org/html/rfc6901">https://tools.ietf.org/html/rfc6901</a> standard, interpreting the current node as the root of its own JSON document.</p>
<p><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">ondemand::parser</a> parser; auto json = R"({ "foo": { "a": [ 10, 20, 30 ] }})"_padded; auto doc = parser.iterate(json); doc.at_pointer("/foo/a/1") == 20</p>
<p>It is allowed for a key to be the empty string:</p>
<p><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">ondemand::parser</a> parser; auto json = R"({ "": { "a": [ 10, 20, 30 ] }})"_padded; auto doc = parser.iterate(json); doc.at_pointer("//a/1") == 20</p>
<p>Note that <a class="el" href="#a9ebe7310eaf678a3fbe0935738bd5818">at_pointer()</a> called on the document automatically calls the document's rewind method between each call. It invalidates all previously accessed arrays, objects and values that have not been consumed. Yet it is not the case when calling at_pointer on an object instance: there is no rewind and no invalidation.</p>
<p>You may call at_pointer more than once on an object, but each time the pointer is advanced to be within the value matched by the key indicated by the JSON pointer query. Thus any preceding key (as well as the current key) can no longer be used with following JSON pointer calls.</p>
<p>Also note that <a class="el" href="#a9ebe7310eaf678a3fbe0935738bd5818">at_pointer()</a> relies on <a class="el" href="#a56bd93c4ad188370f08e83239d1f6843">find_field()</a> which implies that we do not unescape keys when matching.</p>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the given JSON pointer, or:<ul>
<li>NO_SUCH_FIELD if a field does not exist in an object</li>
<li>INDEX_OUT_OF_BOUNDS if an array index is larger than an array length</li>
<li>INCORRECT_TYPE if a non-integer is used to access an array</li>
<li>INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aed92810d20a93f72fbc168d2aca426a5" name="aed92810d20a93f72fbc168d2aca426a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed92810d20a93f72fbc168d2aca426a5">&#9670;&#160;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a> simdjson::fallback::ondemand::object::consume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go to the end of the object, no matter where you are right now. </p>
<p>whenever you are pointing at a key, calling skip_child() is unsafe because you will hit a string and you will assume that it is string value, and this mistake will lead you to make bad depth computation.</p>
<p>We want to 'consume' the key. We could really just do _json_iter-&gt;return_current_and_advance(); at this point, but, for clarity, we will use the high-level API to eat the key. We assume that the compiler optimizes away most of the work.</p>

</div>
</div>
<a id="a3bf0a05579330efd8e79e2255f336cd0" name="a3bf0a05579330efd8e79e2255f336cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf0a05579330efd8e79e2255f336cd0">&#9670;&#160;</a></span>count_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt; simdjson::fallback::ondemand::object::count_fields </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method scans the object and counts the number of key-value pairs. The count_fields method should always be called before you have begun iterating through the object: it is expected that you are pointing at the beginning of the object. The runtime complexity is linear in the size of the object. After calling this function, if successful, the object is 'rewinded' at its beginning as if it had never been accessed. If the JSON is malformed (e.g., there is a missing comma), then an error is returned and it is no longer safe to continue.</p>
<p>To check that an object is empty, it is more performant to use the <a class="el" href="#a8b28b7377207fea100d882230f15897b">is_empty()</a> method.</p>
<p>Performance hint: You should only call <a class="el" href="#a3bf0a05579330efd8e79e2255f336cd0">count_fields()</a> as a last resort as it may require scanning the document twice or more. </p>

</div>
</div>
<a id="a56bd93c4ad188370f08e83239d1f6843" name="a56bd93c4ad188370f08e83239d1f6843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bd93c4ad188370f08e83239d1f6843">&#9670;&#160;</a></span>find_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::object::find_field </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up a field by name on an object (order-sensitive).</p>
<p>The following code reads z, then y, then x, and thus will not retrieve x or y if fed the JSON <code>{ "x": 1, "y": 2, "z": 3 }</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">simdjson::ondemand::parser <a class="code hl_class" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">parser</a>;</div>
<div class="line"><span class="keyword">auto</span> obj = <a class="code hl_class" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">parser</a>.parse(R<span class="stringliteral">&quot;( { &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 } )&quot;_padded);</span></div>
<div class="line"><span class="stringliteral"></span><span class="keywordtype">double</span> z = obj.find_field(<span class="stringliteral">&quot;z&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> y = obj.find_field(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> x = obj.find_field(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="ttc" id="aclasssimdjson_1_1fallback_1_1ondemand_1_1parser_html"><div class="ttname"><a href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">simdjson::fallback::ondemand::parser</a></div><div class="ttdef"><b>Definition</b> simdjson.h:38759</div></div>
</div><!-- fragment --><p> If you have multiple fields with a matching key ({"x": 1, "x": 1}) be mindful that only one field is returned.</p>
<p><b>Raw Keys:</b> The lookup will be done against the <em>raw</em> key, and will not unescape keys. e.g. <code>object["a"]</code> will match <code>{ "a": 1 }</code>, but will <em>not</em> match <code>{ "\u0061": 1 }</code>.</p>
<p>You must consume the fields on an object one at a time. A request for a new key invalidates previous field values: it makes them unsafe. The value instance you get from <code>content["bids"]</code> becomes invalid when you call <code>content["asks"]</code>. The array given by content["bids"].get_array() should not be accessed after you have called content["asks"].get_array(). You can detect such mistakes by first compiling and running the code in Debug mode (or with the macro <code>SIMDJSON_DEVELOPMENT_CHECKS</code> set to 1): an OUT_OF_ORDER_ITERATION error is generated.</p>
<p>You are expected to access keys only once. You should access the value corresponding to a key a single time. Doing object["mykey"].<a class="el" href="namespacesimdjson.html#ade4516933f53705eacfaed65ed14962d">to_string()</a> and then again object["mykey"].<a class="el" href="namespacesimdjson.html#ade4516933f53705eacfaed65ed14962d">to_string()</a> is an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field, or NO_SUCH_FIELD if the field is not in the object. </dd></dl>

</div>
</div>
<a id="a3a1290092ed5d9cf8c80ec3d9811dd2b" name="a3a1290092ed5d9cf8c80ec3d9811dd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1290092ed5d9cf8c80ec3d9811dd2b">&#9670;&#160;</a></span>find_field_unordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::object::find_field_unordered </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look up a field by name on an object, without regard to key order.</p>
<p><b>Performance Notes:</b> This is a bit less performant than <a class="el" href="#a56bd93c4ad188370f08e83239d1f6843">find_field()</a>, though its effect varies and often appears negligible. It starts out normally, starting out at the last field; but if the field is not found, it scans from the beginning of the object to see if it missed it. That missing case has a non-cache-friendly bump and lots of extra scanning, especially if the object in question is large. The fact that the extra code is there also bumps the executable size.</p>
<p>It is the default, however, because it would be highly surprising (and hard to debug) if the default behavior failed to look up a field just because it was in the wrong order&ndash;and many APIs assume this. Therefore, you must be explicit if you want to treat objects as out of order.</p>
<p>Use <a class="el" href="#a56bd93c4ad188370f08e83239d1f6843">find_field()</a> if you are sure fields will be in order (or are willing to treat it as if the field was not there when they are not in order).</p>
<p>If you have multiple fields with a matching key ({"x": 1, "x": 1}) be mindful that only one field is returned.</p>
<p>You must consume the fields on an object one at a time. A request for a new key invalidates previous field values: it makes them unsafe. The value instance you get from <code>content["bids"]</code> becomes invalid when you call <code>content["asks"]</code>. The array given by content["bids"].get_array() should not be accessed after you have called content["asks"].get_array(). You can detect such mistakes by first compiling and running the code in Debug mode (or with the macro <code>SIMDJSON_DEVELOPMENT_CHECKS</code> set to 1): an OUT_OF_ORDER_ITERATION error is generated.</p>
<p>You are expected to access keys only once. You should access the value corresponding to a key a single time. Doing object["mykey"].<a class="el" href="namespacesimdjson.html#ade4516933f53705eacfaed65ed14962d">to_string()</a> and then again object["mykey"].<a class="el" href="namespacesimdjson.html#ade4516933f53705eacfaed65ed14962d">to_string()</a> is an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the field, or NO_SUCH_FIELD if the field is not in the object. </dd></dl>

</div>
</div>
<a id="a8b28b7377207fea100d882230f15897b" name="a8b28b7377207fea100d882230f15897b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b28b7377207fea100d882230f15897b">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::object::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method scans the beginning of the object and checks whether the object is empty. The runtime complexity is constant time. After calling this function, if successful, the object is 'rewinded' at its beginning as if it had never been accessed. If the JSON is malformed (e.g., there is a missing comma), then an error is returned and it is no longer safe to continue. </p>

</div>
</div>
<a id="a294db4609b890ec94c1aeb44b3b2caea" name="a294db4609b890ec94c1aeb44b3b2caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294db4609b890ec94c1aeb44b3b2caea">&#9670;&#160;</a></span>raw_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt; simdjson::fallback::ondemand::object::raw_json </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Consumes the object and returns a string_view instance corresponding to the object as represented in JSON. It points inside the original byte array containing the JSON document. </p>

</div>
</div>
<a id="aa6fb23f375d581d1a664ca3cd9983b53" name="aa6fb23f375d581d1a664ca3cd9983b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fb23f375d581d1a664ca3cd9983b53">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::object::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the iterator so that we are pointing back at the beginning of the object. You should still consume values only once even if you can iterate through the object more than once. If you unescape a string within the object more than once, you have unsafe code. Note that rewinding an object means that you may need to reparse it anew: it is not a free operation.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the object contains some elements (not empty) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/corpus-cleaner/corpus_cleaner/<a class="el" href="simdjson_8h_source.html">simdjson.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
