<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Corpus Cleaner: simdjson::fallback::ondemand::array Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Corpus Cleaner
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesimdjson.html">simdjson</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1fallback.html">fallback</a></li><li class="navelem"><a class="el" href="namespacesimdjson_1_1fallback_1_1ondemand.html">ondemand</a></li><li class="navelem"><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsimdjson_1_1fallback_1_1ondemand_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simdjson::fallback::ondemand::array Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="simdjson_8h_source.html">simdjson.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2162eb035821904cffdb88eb45101ef9" id="r_a2162eb035821904cffdb88eb45101ef9"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2162eb035821904cffdb88eb45101ef9">array</a> () noexcept=default</td></tr>
<tr class="separator:a2162eb035821904cffdb88eb45101ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f7cdad37f6fc03e6813c1e5241de7a" id="r_a25f7cdad37f6fc03e6813c1e5241de7a"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25f7cdad37f6fc03e6813c1e5241de7a">begin</a> () noexcept</td></tr>
<tr class="separator:a25f7cdad37f6fc03e6813c1e5241de7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7857ade11d19f0246981a3bfede2aa55" id="r_a7857ade11d19f0246981a3bfede2aa55"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7857ade11d19f0246981a3bfede2aa55">end</a> () noexcept</td></tr>
<tr class="separator:a7857ade11d19f0246981a3bfede2aa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5599414f1da1fb7f7af557d9f130e2" id="r_aab5599414f1da1fb7f7af557d9f130e2"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab5599414f1da1fb7f7af557d9f130e2">count_elements</a> () &amp;noexcept</td></tr>
<tr class="separator:aab5599414f1da1fb7f7af557d9f130e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af336be8412b0c62e531c7c01b93f381b" id="r_af336be8412b0c62e531c7c01b93f381b"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af336be8412b0c62e531c7c01b93f381b">is_empty</a> () &amp;noexcept</td></tr>
<tr class="separator:af336be8412b0c62e531c7c01b93f381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c2aaff0d7a7353e0c591575c2e856a" id="r_a46c2aaff0d7a7353e0c591575c2e856a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46c2aaff0d7a7353e0c591575c2e856a">reset</a> () &amp;noexcept</td></tr>
<tr class="separator:a46c2aaff0d7a7353e0c591575c2e856a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74563b006045cb457e26a1346785dfa8" id="r_a74563b006045cb457e26a1346785dfa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74563b006045cb457e26a1346785dfa8">at_pointer</a> (std::string_view json_pointer) noexcept</td></tr>
<tr class="separator:a74563b006045cb457e26a1346785dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7007d938d27d6958af72e5ec6c7db00" id="r_af7007d938d27d6958af72e5ec6c7db00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7007d938d27d6958af72e5ec6c7db00">at_path</a> (std::string_view json_path) noexcept</td></tr>
<tr class="separator:af7007d938d27d6958af72e5ec6c7db00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad331fe16347deb29a4e86ea25d9ea593" id="r_ad331fe16347deb29a4e86ea25d9ea593"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad331fe16347deb29a4e86ea25d9ea593">raw_json</a> () noexcept</td></tr>
<tr class="separator:ad331fe16347deb29a4e86ea25d9ea593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6754945c3dbaeb162b195db718339ba1" id="r_a6754945c3dbaeb162b195db718339ba1"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6754945c3dbaeb162b195db718339ba1">at</a> (size_t index) noexcept</td></tr>
<tr class="separator:a6754945c3dbaeb162b195db718339ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a99c7c58610ab175b80ab1c4cae2a5a7f" id="r_a99c7c58610ab175b80ab1c4cae2a5a7f"><td class="memItemLeft" align="right" valign="top">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99c7c58610ab175b80ab1c4cae2a5a7f">consume</a> () noexcept</td></tr>
<tr class="separator:a99c7c58610ab175b80ab1c4cae2a5a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade71d1510b414a9f45d01c3fb531b314" id="r_ade71d1510b414a9f45d01c3fb531b314"><td class="memItemLeft" align="right" valign="top">simdjson_inline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade71d1510b414a9f45d01c3fb531b314">array</a> (const value_iterator &amp;<a class="el" href="#a831dbe58aef8d6c97b740f4763a48877">iter</a>) noexcept</td></tr>
<tr class="separator:ade71d1510b414a9f45d01c3fb531b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a8e9d63c5e907ccc2b451f477f787d37f" id="r_a8e9d63c5e907ccc2b451f477f787d37f"><td class="memItemLeft" align="right" valign="top">static simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e9d63c5e907ccc2b451f477f787d37f">start</a> (value_iterator &amp;<a class="el" href="#a831dbe58aef8d6c97b740f4763a48877">iter</a>) noexcept</td></tr>
<tr class="separator:a8e9d63c5e907ccc2b451f477f787d37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b41f525131aadc305f5d73aecb6205" id="r_ac2b41f525131aadc305f5d73aecb6205"><td class="memItemLeft" align="right" valign="top">static simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2b41f525131aadc305f5d73aecb6205">start_root</a> (value_iterator &amp;<a class="el" href="#a831dbe58aef8d6c97b740f4763a48877">iter</a>) noexcept</td></tr>
<tr class="separator:ac2b41f525131aadc305f5d73aecb6205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccb9851cf460ade98cbe332f5e0d405" id="r_a7ccb9851cf460ade98cbe332f5e0d405"><td class="memItemLeft" align="right" valign="top">static simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ccb9851cf460ade98cbe332f5e0d405">started</a> (value_iterator &amp;<a class="el" href="#a831dbe58aef8d6c97b740f4763a48877">iter</a>) noexcept</td></tr>
<tr class="separator:a7ccb9851cf460ade98cbe332f5e0d405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a831dbe58aef8d6c97b740f4763a48877" id="r_a831dbe58aef8d6c97b740f4763a48877"><td class="memItemLeft" align="right" valign="top">value_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831dbe58aef8d6c97b740f4763a48877">iter</a> {}</td></tr>
<tr class="separator:a831dbe58aef8d6c97b740f4763a48877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae5cda98fa74051d037c0c444c67efb15" id="r_ae5cda98fa74051d037c0c444c67efb15"><td class="memItemLeft" align="right" valign="top"><a id="ae5cda98fa74051d037c0c444c67efb15" name="ae5cda98fa74051d037c0c444c67efb15"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>value</b></td></tr>
<tr class="separator:ae5cda98fa74051d037c0c444c67efb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c20332b4481f29ace969e40cfce5f5f" id="r_a7c20332b4481f29ace969e40cfce5f5f"><td class="memItemLeft" align="right" valign="top"><a id="a7c20332b4481f29ace969e40cfce5f5f" name="a7c20332b4481f29ace969e40cfce5f5f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>document</b></td></tr>
<tr class="separator:a7c20332b4481f29ace969e40cfce5f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad87deba0e08e8188b26485164889fb" id="r_a9ad87deba0e08e8188b26485164889fb"><td class="memItemLeft" align="right" valign="top"><a id="a9ad87deba0e08e8188b26485164889fb" name="a9ad87deba0e08e8188b26485164889fb"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>simdjson_result&lt; value &gt;</b></td></tr>
<tr class="separator:a9ad87deba0e08e8188b26485164889fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad294ba09879c3b42b87298bbc334439b" id="r_ad294ba09879c3b42b87298bbc334439b"><td class="memItemLeft" align="right" valign="top"><a id="ad294ba09879c3b42b87298bbc334439b" name="ad294ba09879c3b42b87298bbc334439b"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>simdjson_result&lt; array &gt;</b></td></tr>
<tr class="separator:ad294ba09879c3b42b87298bbc334439b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7be9f74f64c08fae57eaf36044f7a9" id="r_aec7be9f74f64c08fae57eaf36044f7a9"><td class="memItemLeft" align="right" valign="top"><a id="aec7be9f74f64c08fae57eaf36044f7a9" name="aec7be9f74f64c08fae57eaf36044f7a9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>array_iterator</b></td></tr>
<tr class="separator:aec7be9f74f64c08fae57eaf36044f7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A forward-only JSON array. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2162eb035821904cffdb88eb45101ef9" name="a2162eb035821904cffdb88eb45101ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2162eb035821904cffdb88eb45101ef9">&#9670;&#160;</a></span>array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::fallback::ondemand::array::array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new invalid array.</p>
<p>Exists so you can declare a variable and later assign to it before use. </p>

</div>
</div>
<a id="ade71d1510b414a9f45d01c3fb531b314" name="ade71d1510b414a9f45d01c3fb531b314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade71d1510b414a9f45d01c3fb531b314">&#9670;&#160;</a></span>array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline simdjson::fallback::ondemand::array::array </td>
          <td>(</td>
          <td class="paramtype">const value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an array at the given Internal array creation. Call <a class="el" href="#a8e9d63c5e907ccc2b451f477f787d37f">array::start()</a> or <a class="el" href="#a7ccb9851cf460ade98cbe332f5e0d405">array::started()</a> instead of this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. Must either be at the start of the first element with iter.is_alive() == true, or past the [] with is_alive() == false if the array is empty. Will be <em>moved</em> into the resulting array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6754945c3dbaeb162b195db718339ba1" name="a6754945c3dbaeb162b195db718339ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6754945c3dbaeb162b195db718339ba1">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::array::at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value at the given index. This function has linear-time complexity. This function should only be called once on an array instance since the array iterator is not reset between each call.</p>
<dl class="section return"><dt>Returns</dt><dd>The value at the given index, or:<ul>
<li>INDEX_OUT_OF_BOUNDS if the array index is larger than an array length </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af7007d938d27d6958af72e5ec6c7db00" name="af7007d938d27d6958af72e5ec6c7db00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7007d938d27d6958af72e5ec6c7db00">&#9670;&#160;</a></span>at_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::array::at_path </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>json_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value associated with the given JSONPath expression. We only support JSONPath queries that trivially convertible to JSON Pointer queries: key names and array indices.</p>
<p><a href="https://datatracker.ietf.org/doc/html/draft-normington-jsonpath-00">https://datatracker.ietf.org/doc/html/draft-normington-jsonpath-00</a></p>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the given JSONPath expression, or:<ul>
<li>INVALID_JSON_POINTER if the JSONPath to JSON Pointer conversion fails</li>
<li>NO_SUCH_FIELD if a field does not exist in an object</li>
<li>INDEX_OUT_OF_BOUNDS if an array index is larger than an array length</li>
<li>INCORRECT_TYPE if a non-integer is used to access an array </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a74563b006045cb457e26a1346785dfa8" name="a74563b006045cb457e26a1346785dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74563b006045cb457e26a1346785dfa8">&#9670;&#160;</a></span>at_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1value.html">value</a> &gt; simdjson::fallback::ondemand::array::at_pointer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>json_pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value associated with the given JSON pointer. We use the RFC 6901 <a href="https://tools.ietf.org/html/rfc6901">https://tools.ietf.org/html/rfc6901</a> standard, interpreting the current node as the root of its own JSON document.</p>
<p><a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1parser.html">ondemand::parser</a> parser; auto json = R"([ { "foo": { "a": [ 10, 20, 30 ] }} ])"_padded; auto doc = parser.iterate(json); doc.at_pointer("/0/foo/a/1") == 20</p>
<p>Note that <a class="el" href="#a74563b006045cb457e26a1346785dfa8">at_pointer()</a> called on the document automatically calls the document's rewind method between each call. It invalidates all previously accessed arrays, objects and values that have not been consumed. Yet it is not the case when calling at_pointer on an array instance: there is no rewind and no invalidation.</p>
<p>You may only call at_pointer on an array after it has been created, but before it has been first accessed. When calling at_pointer on an array, the pointer is advanced to the location indicated by the JSON pointer (in case of success). It is no longer possible to call at_pointer on the same array.</p>
<p>Also note that <a class="el" href="#a74563b006045cb457e26a1346785dfa8">at_pointer()</a> relies on find_field() which implies that we do not unescape keys when matching.</p>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the given JSON pointer, or:<ul>
<li>NO_SUCH_FIELD if a field does not exist in an object</li>
<li>INDEX_OUT_OF_BOUNDS if an array index is larger than an array length</li>
<li>INCORRECT_TYPE if a non-integer is used to access an array</li>
<li>INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a25f7cdad37f6fc03e6813c1e5241de7a" name="a25f7cdad37f6fc03e6813c1e5241de7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f7cdad37f6fc03e6813c1e5241de7a">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt; simdjson::fallback::ondemand::array::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin array iteration.</p>
<p>Part of the std::iterable interface. </p>

</div>
</div>
<a id="a99c7c58610ab175b80ab1c4cae2a5a7f" name="a99c7c58610ab175b80ab1c4cae2a5a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c7c58610ab175b80ab1c4cae2a5a7f">&#9670;&#160;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="namespacesimdjson.html#a7b735a3a50ba79e3f7f14df5f77d8da9">error_code</a> simdjson::fallback::ondemand::array::consume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go to the end of the array, no matter where you are right now. </p>

</div>
</div>
<a id="aab5599414f1da1fb7f7af557d9f130e2" name="aab5599414f1da1fb7f7af557d9f130e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5599414f1da1fb7f7af557d9f130e2">&#9670;&#160;</a></span>count_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SIMDJSON_PUSH_DISABLE_WARNINGS SIMDJSON_DISABLE_STRICT_OVERFLOW_WARNING simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; size_t &gt; simdjson::fallback::ondemand::array::count_elements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method scans the array and counts the number of elements. The count_elements method should always be called before you have begun iterating through the array: it is expected that you are pointing at the beginning of the array. The runtime complexity is linear in the size of the array. After calling this function, if successful, the array is 'rewinded' at its beginning as if it had never been accessed. If the JSON is malformed (e.g., there is a missing comma), then an error is returned and it is no longer safe to continue.</p>
<p>To check that an array is empty, it is more performant to use the <a class="el" href="#af336be8412b0c62e531c7c01b93f381b">is_empty()</a> method. </p>

</div>
</div>
<a id="a7857ade11d19f0246981a3bfede2aa55" name="a7857ade11d19f0246981a3bfede2aa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7857ade11d19f0246981a3bfede2aa55">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array__iterator.html">array_iterator</a> &gt; simdjson::fallback::ondemand::array::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sentinel representing the end of the array.</p>
<p>Part of the std::iterable interface. </p>

</div>
</div>
<a id="af336be8412b0c62e531c7c01b93f381b" name="af336be8412b0c62e531c7c01b93f381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af336be8412b0c62e531c7c01b93f381b">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SIMDJSON_POP_DISABLE_WARNINGS simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::array::is_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method scans the beginning of the array and checks whether the array is empty. The runtime complexity is constant time. After calling this function, if successful, the array is 'rewinded' at its beginning as if it had never been accessed. If the JSON is malformed (e.g., there is a missing comma), then an error is returned and it is no longer safe to continue. </p>

</div>
</div>
<a id="ad331fe16347deb29a4e86ea25d9ea593" name="ad331fe16347deb29a4e86ea25d9ea593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad331fe16347deb29a4e86ea25d9ea593">&#9670;&#160;</a></span>raw_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; std::string_view &gt; simdjson::fallback::ondemand::array::raw_json </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Consumes the array and returns a string_view instance corresponding to the array as represented in JSON. It points inside the original document. </p>

</div>
</div>
<a id="a46c2aaff0d7a7353e0c591575c2e856a" name="a46c2aaff0d7a7353e0c591575c2e856a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c2aaff0d7a7353e0c591575c2e856a">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; bool &gt; simdjson::fallback::ondemand::array::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the iterator so that we are pointing back at the beginning of the array. You should still consume values only once even if you can iterate through the array more than once. If you unescape a string within the array more than once, you have unsafe code. Note that rewinding an array means that you may need to reparse it anew: it is not a free operation.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the array contains some elements (not empty) </dd></dl>

</div>
</div>
<a id="a8e9d63c5e907ccc2b451f477f787d37f" name="a8e9d63c5e907ccc2b451f477f787d37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9d63c5e907ccc2b451f477f787d37f">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt; simdjson::fallback::ondemand::array::start </td>
          <td>(</td>
          <td class="paramtype">value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin array iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. Must be where the initial [ is expected. Will be <em>moved</em> into the resulting array. @error INCORRECT_TYPE if the iterator is not at [. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2b41f525131aadc305f5d73aecb6205" name="ac2b41f525131aadc305f5d73aecb6205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b41f525131aadc305f5d73aecb6205">&#9670;&#160;</a></span>start_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt; simdjson::fallback::ondemand::array::start_root </td>
          <td>(</td>
          <td class="paramtype">value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin array iteration from the root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. Must be where the initial [ is expected. Will be <em>moved</em> into the resulting array. @error INCORRECT_TYPE if the iterator is not at [. @error TAPE_ERROR if there is no closing ] at the end of the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ccb9851cf460ade98cbe332f5e0d405" name="a7ccb9851cf460ade98cbe332f5e0d405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccb9851cf460ade98cbe332f5e0d405">&#9670;&#160;</a></span>started()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdjson_inline <a class="el" href="structsimdjson_1_1simdjson__result.html">simdjson_result</a>&lt; <a class="el" href="classsimdjson_1_1fallback_1_1ondemand_1_1array.html">array</a> &gt; simdjson::fallback::ondemand::array::started </td>
          <td>(</td>
          <td class="paramtype">value_iterator &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin array iteration.</p>
<p>This version of the method should be called after the initial [ has been verified, and is intended for use by switch statements that check the type of a value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator. Must be after the initial [. Will be <em>moved</em> into the resulting array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a831dbe58aef8d6c97b740f4763a48877" name="a831dbe58aef8d6c97b740f4763a48877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831dbe58aef8d6c97b740f4763a48877">&#9670;&#160;</a></span>iter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_iterator simdjson::fallback::ondemand::array::iter {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator marking current position.</p>
<p>iter.is_alive() == false indicates iteration is complete. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/corpus-cleaner/corpus_cleaner/<a class="el" href="simdjson_8h_source.html">simdjson.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
