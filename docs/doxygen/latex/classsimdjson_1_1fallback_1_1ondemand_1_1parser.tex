\doxysection{simdjson\+::fallback\+::ondemand\+::parser Class Reference}
\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser}\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}


{\ttfamily \#include $<$simdjson.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aacf57bcdbef82fbf13a9d9f3d660a50a}{parser}} (size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adfe685ba09ccfe5f49cb3fbcbcf9cf8c}{max\+\_\+capacity}}=\mbox{\hyperlink{namespacesimdjson_ad0bad3783275be4012bd5cfd0327875a}{SIMDJSON\+\_\+\+MAXSIZE\+\_\+\+BYTES}}) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a1fd435ca072483a0eb579ebdaff9f0b5}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a1fd435ca072483a0eb579ebdaff9f0b5} 
{\bfseries parser} (\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{parser}} \&\&other) noexcept=default
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adefdcf1523e19d3ea29b25efb1b52932}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adefdcf1523e19d3ea29b25efb1b52932} 
simdjson\+\_\+inline {\bfseries parser} (const \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{parser}} \&other)=delete
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3ad7aa6913c140c61e3a9c79d69b6f50}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3ad7aa6913c140c61e3a9c79d69b6f50} 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{parser}} \& {\bfseries operator=} (const \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{parser}} \&other)=delete
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_ad0a4e0c18b45d9423de1b635a2de910c}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_ad0a4e0c18b45d9423de1b635a2de910c} 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{parser}} \& {\bfseries operator=} (\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{parser}} \&\&other) noexcept=default
\item 
\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a4a997d1804455dcafcabea5027204748}{\texorpdfstring{$\sim$}{\string~}parser}} () noexcept=default
\item 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a416104ab177f4916f1af7c2ecc2287e1}{iterate}} (\mbox{\hyperlink{classsimdjson_1_1padded__string__view}{padded\+\_\+string\+\_\+view}} json) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2e596129fe3a08da06d493216e6bde3c}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2e596129fe3a08da06d493216e6bde3c} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (const char \texorpdfstring{$\ast$}{*}json, size\+\_\+t len, size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4}{capacity}}) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_afa19f54a6233f78d74492bff7038e8a8}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_afa19f54a6233f78d74492bff7038e8a8} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (const uint8\+\_\+t \texorpdfstring{$\ast$}{*}json, size\+\_\+t len, size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4}{capacity}}) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a5544e1c339005d392473c9609b95850e}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a5544e1c339005d392473c9609b95850e} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (std\+::string\+\_\+view json, size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4}{capacity}}) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3aa6e4d987fba0639063a15c0747486a}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3aa6e4d987fba0639063a15c0747486a} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (const std\+::string \&json) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_ac6dd8de47a5b8ba246f389cac7339e4c}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_ac6dd8de47a5b8ba246f389cac7339e4c} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (std\+::string \&json) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a4603f0f104a995df409290eb5c31e067}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a4603f0f104a995df409290eb5c31e067} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (const \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} $>$ \&json) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a548e7bbf60b72aff45e30629fbe34746}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a548e7bbf60b72aff45e30629fbe34746} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (const \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1padded__string__view}{padded\+\_\+string\+\_\+view}} $>$ \&json) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_acede05fceb3f0e630aade1421edb88f1}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_acede05fceb3f0e630aade1421edb88f1} 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ {\bfseries iterate} (\mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} \&\&json) \&noexcept=delete
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_af241fec8a87b18520843187df8b313e6}{iterate\+\_\+many}} (const uint8\+\_\+t \texorpdfstring{$\ast$}{*}buf, size\+\_\+t len, size\+\_\+t batch\+\_\+size=DEFAULT\+\_\+\+BATCH\+\_\+\+SIZE, bool allow\+\_\+comma\+\_\+separated=false) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2d24ff95da0b42c29d5209f2a5f203dd}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2d24ff95da0b42c29d5209f2a5f203dd} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries iterate\+\_\+many} (const char \texorpdfstring{$\ast$}{*}buf, size\+\_\+t len, size\+\_\+t batch\+\_\+size=DEFAULT\+\_\+\+BATCH\+\_\+\+SIZE, bool allow\+\_\+comma\+\_\+separated=false) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3a4c6314ac4d722316589ff1ac404f9c}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3a4c6314ac4d722316589ff1ac404f9c} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries iterate\+\_\+many} (const std\+::string \&s, size\+\_\+t batch\+\_\+size=DEFAULT\+\_\+\+BATCH\+\_\+\+SIZE, bool allow\+\_\+comma\+\_\+separated=false) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3c78e027f6eb853df7a7799cf6b135b5}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a3c78e027f6eb853df7a7799cf6b135b5} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries iterate\+\_\+many} (const std\+::string \&\&s, size\+\_\+t batch\+\_\+size, bool allow\+\_\+comma\+\_\+separated=false)=delete
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a73812f1b30062fa369b0292faf6d6ac4}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a73812f1b30062fa369b0292faf6d6ac4} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries iterate\+\_\+many} (const \mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} \&s, size\+\_\+t batch\+\_\+size=DEFAULT\+\_\+\+BATCH\+\_\+\+SIZE, bool allow\+\_\+comma\+\_\+separated=false) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7c995b34cfd5682867a43e674cf73515}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7c995b34cfd5682867a43e674cf73515} 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ {\bfseries iterate\+\_\+many} (const \mbox{\hyperlink{structsimdjson_1_1padded__string}{padded\+\_\+string}} \&\&s, size\+\_\+t batch\+\_\+size, bool allow\+\_\+comma\+\_\+separated=false)=delete
\item 
simdjson\+\_\+inline size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4}{capacity}} () const noexcept
\item 
simdjson\+\_\+inline size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adfe685ba09ccfe5f49cb3fbcbcf9cf8c}{max\+\_\+capacity}} () const noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2cc3b90d9a9aae362b2d7fba6b2a1b0c}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2cc3b90d9a9aae362b2d7fba6b2a1b0c} 
simdjson\+\_\+inline void {\bfseries set\+\_\+max\+\_\+capacity} (size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adfe685ba09ccfe5f49cb3fbcbcf9cf8c}{max\+\_\+capacity}}) noexcept
\item 
simdjson\+\_\+inline size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7e82a1e063ff6a5b60a92738e9aed23e}{max\+\_\+depth}} () const noexcept
\item 
simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_afc07aae278c104e94b125a40d8b0c37e}{allocate}} (size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4}{capacity}}, size\+\_\+t \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7e82a1e063ff6a5b60a92738e9aed23e}{max\+\_\+depth}}=\mbox{\hyperlink{namespacesimdjson_a6df2598eb1d4e1ea669c41831cc7325d}{DEFAULT\+\_\+\+MAX\+\_\+\+DEPTH}}) noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aba8f934226bd7a5996b327ac253356e2}{unescape}} (\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}} in, uint8\+\_\+t \texorpdfstring{$\ast$}{*}\&dst, bool allow\+\_\+replacement=false) const noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2a4ee5ca44bfd719964d2314532bed95}{unescape\+\_\+wobbly}} (\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}} in, uint8\+\_\+t \texorpdfstring{$\ast$}{*}\&dst) const noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7a0d2e5fad4f195a866b6baa15846d39}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7a0d2e5fad4f195a866b6baa15846d39} 
class {\bfseries json\+\_\+iterator}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a403473bb5329fca6defc6299fb45b780}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a403473bb5329fca6defc6299fb45b780} 
class {\bfseries document\+\_\+stream}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A JSON fragment iterator.

This holds the actual iterator as well as the buffer for writing strings. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aacf57bcdbef82fbf13a9d9f3d660a50a}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aacf57bcdbef82fbf13a9d9f3d660a50a} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!parser@{parser}}
\index{parser@{parser}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{parser()}{parser()}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+::fallback\+::ondemand\+::parser\+::parser (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{max\+\_\+capacity = {\ttfamily \mbox{\hyperlink{namespacesimdjson_ad0bad3783275be4012bd5cfd0327875a}{SIMDJSON\+\_\+\+MAXSIZE\+\_\+\+BYTES}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}, {\ttfamily [noexcept]}}

Create a JSON parser.

The new parser will have zero capacity. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a4a997d1804455dcafcabea5027204748}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a4a997d1804455dcafcabea5027204748} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!````~parser@{\texorpdfstring{$\sim$}{\string~}parser}}
\index{````~parser@{\texorpdfstring{$\sim$}{\string~}parser}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}parser()}{\string~parser()}}
{\footnotesize\ttfamily simdjson\+::fallback\+::ondemand\+::parser\+::\texorpdfstring{$\sim$}{\string~}parser (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [default]}, {\ttfamily [noexcept]}}

Deallocate the JSON parser. 

\doxysubsection{Member Function Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_afc07aae278c104e94b125a40d8b0c37e}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_afc07aae278c104e94b125a40d8b0c37e} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!allocate@{allocate}}
\index{allocate@{allocate}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} simdjson\+::fallback\+::ondemand\+::parser\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{capacity,  }\item[{size\+\_\+t}]{max\+\_\+depth = {\ttfamily \mbox{\hyperlink{namespacesimdjson_a6df2598eb1d4e1ea669c41831cc7325d}{DEFAULT\+\_\+\+MAX\+\_\+\+DEPTH}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Ensure this parser has enough memory to process JSON documents up to {\ttfamily capacity} bytes in length and {\ttfamily max\+\_\+depth} depth.

The max\+\_\+depth parameter is only relevant when the macro SIMDJSON\+\_\+\+DEVELOPMENT\+\_\+\+CHECKS is set to true. The document\textquotesingle{}s instance current\+\_\+depth() method should be used to monitor the parsing depth and limit it if desired.


\begin{DoxyParams}{Parameters}
{\em capacity} & The new capacity. \\
\hline
{\em max\+\_\+depth} & The new max\+\_\+depth. Defaults to DEFAULT\+\_\+\+MAX\+\_\+\+DEPTH. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The error, if there is one. 
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aca0f755f01db65068257b46b3bc215a4} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!capacity@{capacity}}
\index{capacity@{capacity}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily simdjson\+\_\+inline size\+\_\+t simdjson\+::fallback\+::ondemand\+::parser\+::capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

The capacity of this parser (the largest document it can process). \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a416104ab177f4916f1af7c2ecc2287e1}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a416104ab177f4916f1af7c2ecc2287e1} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!iterate@{iterate}}
\index{iterate@{iterate}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{iterate()}{iterate()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document}{document}} $>$ simdjson\+::fallback\+::ondemand\+::parser\+::iterate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsimdjson_1_1padded__string__view}{padded\+\_\+string\+\_\+view}}}]{json }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [noexcept]}}

Start iterating an on-\/demand JSON document.

\doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{ondemand\+::parser} parser; document doc = parser.\+iterate(json);

It is expected that the content is a valid UTF-\/8 file, containing a valid JSON document. Otherwise the iterate method may return an error. In particular, the whole input should be valid\+: we do not attempt to tolerate incorrect content either before or after a JSON document. If there is a UTF-\/8 BOM, the parser skips it.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md18}{}\doxysubsubsubsection{\texorpdfstring{IMPORTANT\+: Validate what you use}{IMPORTANT\+: Validate what you use}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md18}
Calling iterate on an invalid JSON document may not immediately trigger an error. The call to iterate does not parse and validate the whole document.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md19}{}\doxysubsubsubsection{\texorpdfstring{IMPORTANT\+: Buffer Lifetime}{IMPORTANT\+: Buffer Lifetime}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md19}
Because parsing is done while you iterate, you {\itshape must} keep the JSON buffer around at least as long as the document iteration.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md20}{}\doxysubsubsubsection{\texorpdfstring{IMPORTANT\+: Document Lifetime}{IMPORTANT\+: Document Lifetime}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md20}
Only one iteration at a time can happen per parser, and the parser {\itshape must} be kept alive during iteration to ensure intermediate buffers can be accessed. Any document must be destroyed before you call parse() again or destroy the parser.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md21}{}\doxysubsubsubsection{\texorpdfstring{REQUIRED\+: Buffer Padding}{REQUIRED\+: Buffer Padding}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md21}
The buffer must have at least SIMDJSON\+\_\+\+PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated. These bytes will be read\+: if you using a sanitizer that verifies that no uninitialized byte is read, then you should initialize the SIMDJSON\+\_\+\+PADDING bytes to avoid runtime warnings.


\begin{DoxyParams}{Parameters}
{\em json} & The JSON to parse. \\
\hline
{\em len} & The length of the JSON. \\
\hline
{\em capacity} & The number of bytes allocated in the JSON (must be at least len+\+SIMDJSON\+\_\+\+PADDING).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The document, or an error\+:
\begin{DoxyItemize}
\item INSUFFICIENT\+\_\+\+PADDING if the input has less than SIMDJSON\+\_\+\+PADDING extra bytes.
\item MEMALLOC if realloc\+\_\+if\+\_\+needed the parser does not have enough capacity, and memory allocation fails.
\item EMPTY if the document is all whitespace.
\item UTF8\+\_\+\+ERROR if the document is not valid UTF-\/8.
\item UNESCAPED\+\_\+\+CHARS if a string contains control characters that must be escaped
\item UNCLOSED\+\_\+\+STRING if there is an unclosed string in the document. 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_af241fec8a87b18520843187df8b313e6}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_af241fec8a87b18520843187df8b313e6} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!iterate\_many@{iterate\_many}}
\index{iterate\_many@{iterate\_many}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{iterate\_many()}{iterate\_many()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{document\+\_\+stream}} $>$ simdjson\+::fallback\+::ondemand\+::parser\+::iterate\+\_\+many (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t \texorpdfstring{$\ast$}{*}}]{buf,  }\item[{size\+\_\+t}]{len,  }\item[{size\+\_\+t}]{batch\+\_\+size = {\ttfamily DEFAULT\+\_\+BATCH\+\_\+SIZE},  }\item[{bool}]{allow\+\_\+comma\+\_\+separated = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Parse a buffer containing many JSON documents.

auto json = R"{}(\{ "{}foo"{}\+: 1 \} \{ "{}foo"{}\+: 2 \} \{ "{}foo"{}\+: 3 \} )"{}\+\_\+padded; \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{ondemand\+::parser} parser; \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1document__stream}{ondemand\+::document\+\_\+stream} docs = parser.\+iterate\+\_\+many(json); for (auto \& doc \+: docs) \{ std\+::cout \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} doc\mbox{[}"{}foo"{}\mbox{]} \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} std\+::endl; \} // Prints 1 2 3

No copy of the input buffer is made.

The function is lazy\+: it may be that no more than one JSON document at a time is parsed.

The caller is responsabile to ensure that the input string data remains unchanged and is not deleted during the loop.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md25}{}\doxysubsubsubsection{\texorpdfstring{Format}{Format}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md25}
The buffer must contain a series of one or more JSON documents, concatenated into a single buffer, separated by ASCII whitespace. It effectively parses until it has a fully valid document, then starts parsing the next document at that point. (It does this with more parallelism and lookahead than you might think, though.)

documents that consist of an object or array may omit the whitespace between them, concatenating with no separator. Documents that consist of a single primitive (i.\+e. documents that are not arrays or objects) MUST be separated with ASCII whitespace.

The characters inside a JSON document, and between JSON documents, must be valid Unicode (UTF-\/8). If there is a UTF-\/8 BOM, the parser skips it.

The documents must not exceed batch\+\_\+size bytes (by default 1MB) or they will fail to parse. Setting batch\+\_\+size to excessively large or excessively small values may impact negatively the performance.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md26}{}\doxysubsubsubsection{\texorpdfstring{REQUIRED\+: Buffer Padding}{REQUIRED\+: Buffer Padding}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md26}
The buffer must have at least SIMDJSON\+\_\+\+PADDING extra allocated bytes. It does not matter what those bytes are initialized to, as long as they are allocated. These bytes will be read\+: if you using a sanitizer that verifies that no uninitialized byte is read, then you should initialize the SIMDJSON\+\_\+\+PADDING bytes to avoid runtime warnings.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md27}{}\doxysubsubsubsection{\texorpdfstring{Threads}{Threads}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md27}
When compiled with SIMDJSON\+\_\+\+THREADS\+\_\+\+ENABLED, this method will use a single thread under the hood to do some lookahead.\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md28}{}\doxysubsubsubsection{\texorpdfstring{Parser Capacity}{Parser Capacity}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md28}
If the parser\textquotesingle{}s current capacity is less than batch\+\_\+size, it will allocate enough capacity to handle it (up to max\+\_\+capacity).


\begin{DoxyParams}{Parameters}
{\em buf} & The concatenated JSON to parse. \\
\hline
{\em len} & The length of the concatenated JSON. \\
\hline
{\em batch\+\_\+size} & The batch size to use. MUST be larger than the largest document. The sweet spot is cache-\/related\+: small enough to fit in cache, yet big enough to parse as many documents as possible in one tight loop. Defaults to 10MB, which has been a reasonable sweet spot in our tests. \\
\hline
{\em allow\+\_\+comma\+\_\+separated} & (defaults on false) This allows a mode where the documents are separated by commas instead of whitespace. It comes with a performance penalty because the entire document is indexed at once (and the document must be less than 4 GB), and there is no multithreading. In this mode, the batch\+\_\+size parameter is effectively ignored, as it is set to at least the document size. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The stream, or an error. An empty input will yield 0 documents rather than an EMPTY error. Errors\+:
\begin{DoxyItemize}
\item MEMALLOC if the parser does not have enough capacity and memory allocation fails
\item CAPACITY if the parser does not have enough capacity and batch\+\_\+size \texorpdfstring{$>$}{>} max\+\_\+capacity.
\item other json errors if parsing fails. You should not rely on these errors to always the same for the same document\+: they may vary under runtime dispatch (so they may vary depending on your system and hardware). 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adfe685ba09ccfe5f49cb3fbcbcf9cf8c}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_adfe685ba09ccfe5f49cb3fbcbcf9cf8c} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!max\_capacity@{max\_capacity}}
\index{max\_capacity@{max\_capacity}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{max\_capacity()}{max\_capacity()}}
{\footnotesize\ttfamily simdjson\+\_\+inline size\+\_\+t simdjson\+::fallback\+::ondemand\+::parser\+::max\+\_\+capacity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

The maximum capacity of this parser (the largest document it is allowed to process). \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7e82a1e063ff6a5b60a92738e9aed23e}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a7e82a1e063ff6a5b60a92738e9aed23e} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!max\_depth@{max\_depth}}
\index{max\_depth@{max\_depth}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{max\_depth()}{max\_depth()}}
{\footnotesize\ttfamily simdjson\+\_\+inline size\+\_\+t simdjson\+::fallback\+::ondemand\+::parser\+::max\+\_\+depth (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

The maximum depth of this parser (the most deeply nested objects and arrays it can process). This parameter is only relevant when the macro SIMDJSON\+\_\+\+DEVELOPMENT\+\_\+\+CHECKS is set to true. The document\textquotesingle{}s instance current\+\_\+depth() method should be used to monitor the parsing depth and limit it if desired. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aba8f934226bd7a5996b327ac253356e2}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_aba8f934226bd7a5996b327ac253356e2} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!unescape@{unescape}}
\index{unescape@{unescape}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{unescape()}{unescape()}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ simdjson\+::fallback\+::ondemand\+::parser\+::unescape (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}}}]{in,  }\item[{uint8\+\_\+t \texorpdfstring{$\ast$}{*}\&}]{dst,  }\item[{bool}]{allow\+\_\+replacement = {\ttfamily false} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Unescape this JSON string, replacing \textbackslash{} with \textbackslash{}, ~\newline
 with newline, etc. to a user-\/provided buffer. The result must be valid UTF-\/8. The provided pointer is advanced to the end of the string by reference, and a string\+\_\+view instance is returned. You can ensure that your buffer is large enough by allocating a block of memory at least as large as the input JSON plus SIMDJSON\+\_\+\+PADDING and then unescape all strings to this one buffer.

This unescape function is a low-\/level function. If you want a more user-\/friendly approach, you should avoid \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instances (e.\+g., by calling unescaped\+\_\+key() instead of key() or get\+\_\+string() instead of get\+\_\+raw\+\_\+json\+\_\+string()).\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md29}{}\doxysubsubsection{\texorpdfstring{IMPORTANT\+: string\+\_\+view lifetime}{IMPORTANT\+: string\+\_\+view lifetime}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md29}
The string\+\_\+view is only valid as long as the bytes in dst.


\begin{DoxyParams}{Parameters}
{\em \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}} & input \\
\hline
{\em dst} & A pointer to a buffer at least large enough to write this string as well as an additional SIMDJSON\+\_\+\+PADDING bytes. \\
\hline
{\em allow\+\_\+replacement} & Whether we allow a replacement if the input string contains unmatched surrogate pairs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string\+\_\+view pointing at the unescaped string in dst @error STRING\+\_\+\+ERROR if escapes are incorrect. 
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2a4ee5ca44bfd719964d2314532bed95}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_a2a4ee5ca44bfd719964d2314532bed95} 
\index{simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}!unescape\_wobbly@{unescape\_wobbly}}
\index{unescape\_wobbly@{unescape\_wobbly}!simdjson::fallback::ondemand::parser@{simdjson::fallback::ondemand::parser}}
\doxysubsubsection{\texorpdfstring{unescape\_wobbly()}{unescape\_wobbly()}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+\_\+warn\+\_\+unused \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ simdjson\+::fallback\+::ondemand\+::parser\+::unescape\+\_\+wobbly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}}}]{in,  }\item[{uint8\+\_\+t \texorpdfstring{$\ast$}{*}\&}]{dst }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Unescape this JSON string, replacing \textbackslash{} with \textbackslash{}, ~\newline
 with newline, etc. to a user-\/provided buffer. The result may not be valid UTF-\/8. See \href{https://simonsapin.github.io/wtf-8/}{\texttt{ https\+://simonsapin.\+github.\+io/wtf-\/8/}} The provided pointer is advanced to the end of the string by reference, and a string\+\_\+view instance is returned. You can ensure that your buffer is large enough by allocating a block of memory at least as large as the input JSON plus SIMDJSON\+\_\+\+PADDING and then unescape all strings to this one buffer.

This unescape function is a low-\/level function. If you want a more user-\/friendly approach, you should avoid \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string} instances (e.\+g., by calling unescaped\+\_\+key() instead of key() or get\+\_\+string() instead of get\+\_\+raw\+\_\+json\+\_\+string()).\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md30}{}\doxysubsubsection{\texorpdfstring{IMPORTANT\+: string\+\_\+view lifetime}{IMPORTANT\+: string\+\_\+view lifetime}}\label{classsimdjson_1_1fallback_1_1ondemand_1_1parser_autotoc_md30}
The string\+\_\+view is only valid as long as the bytes in dst.


\begin{DoxyParams}{Parameters}
{\em \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}} & input \\
\hline
{\em dst} & A pointer to a buffer at least large enough to write this string as well as an additional SIMDJSON\+\_\+\+PADDING bytes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string\+\_\+view pointing at the unescaped string in dst @error STRING\+\_\+\+ERROR if escapes are incorrect. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/corpus-\/cleaner/corpus\+\_\+cleaner/simdjson.\+h\end{DoxyCompactItemize}
