\doxysection{simdjson\+::fallback\+::ondemand\+::object Class Reference}
\hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object}{}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object}\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}


{\ttfamily \#include $<$simdjson.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a11782810fac89fc282535e42d25bab56}{object}} () noexcept=default
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_ad405e01b709aa94c3104a55b5f00511a}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_ad405e01b709aa94c3104a55b5f00511a} 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object__iterator}{object\+\_\+iterator}} $>$ {\bfseries begin} () noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a4cca970cfdca2d210902c301f1c9b662}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a4cca970cfdca2d210902c301f1c9b662} 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object__iterator}{object\+\_\+iterator}} $>$ {\bfseries end} () noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a56bd93c4ad188370f08e83239d1f6843}{find\+\_\+field}} (std\+::string\+\_\+view key) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a92e2bff7e74345727ca8bc081f505f7b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a92e2bff7e74345727ca8bc081f505f7b} 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ {\bfseries find\+\_\+field} (std\+::string\+\_\+view key) \&\&noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3a1290092ed5d9cf8c80ec3d9811dd2b}{find\+\_\+field\+\_\+unordered}} (std\+::string\+\_\+view key) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa62d1c4096ba842ddcb6b9c644e6c0ae}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa62d1c4096ba842ddcb6b9c644e6c0ae} 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ {\bfseries find\+\_\+field\+\_\+unordered} (std\+::string\+\_\+view key) \&\&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a639aefc8292461d1ce5d2c5fbf52b2d9}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a639aefc8292461d1ce5d2c5fbf52b2d9} 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ {\bfseries operator\mbox{[}$\,$\mbox{]}} (std\+::string\+\_\+view key) \&noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3f46d81067ab513d87572dd57f9f17d9}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3f46d81067ab513d87572dd57f9f17d9} 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ {\bfseries operator\mbox{[}$\,$\mbox{]}} (std\+::string\+\_\+view key) \&\&noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a9ebe7310eaf678a3fbe0935738bd5818}{at\+\_\+pointer}} (std\+::string\+\_\+view json\+\_\+pointer) noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a156a49869fabb446d8501ae4e4f82c57}{at\+\_\+path}} (std\+::string\+\_\+view json\+\_\+path) noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa6fb23f375d581d1a664ca3cd9983b53}{reset}} () \&noexcept
\item 
\mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a8b28b7377207fea100d882230f15897b}{is\+\_\+empty}} () \&noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ size\+\_\+t $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3bf0a05579330efd8e79e2255f336cd0}{count\+\_\+fields}} () \&noexcept
\item 
simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a294db4609b890ec94c1aeb44b3b2caea}{raw\+\_\+json}} () noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object_aed92810d20a93f72fbc168d2aca426a5}{consume}} () noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a265486c6c2016848dfa0bdbafc6cec34}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a265486c6c2016848dfa0bdbafc6cec34} 
simdjson\+\_\+inline {\bfseries object} (const value\+\_\+iterator \&iter) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a4a32129c844fdf1e188e6fe65f240059}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a4a32129c844fdf1e188e6fe65f240059} 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} {\bfseries find\+\_\+field\+\_\+raw} (const std\+::string\+\_\+view key) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a5355de366d1b7ab670563e269b355c87}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a5355de366d1b7ab670563e269b355c87} 
static simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object}{object}} $>$ {\bfseries start} (value\+\_\+iterator \&iter) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a4983dc7d7b9d683b637e6cfeefa7ba49}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a4983dc7d7b9d683b637e6cfeefa7ba49} 
static simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object}{object}} $>$ {\bfseries start\+\_\+root} (value\+\_\+iterator \&iter) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a868e9895c37ace90548d329a53ed5691}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a868e9895c37ace90548d329a53ed5691} 
static simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object}{object}} $>$ {\bfseries started} (value\+\_\+iterator \&iter) noexcept
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a59c3ee00c788fd518e25d3e2641f8619}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a59c3ee00c788fd518e25d3e2641f8619} 
static simdjson\+\_\+inline \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1object}{object}} {\bfseries resume} (const value\+\_\+iterator \&iter) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_ac781adb849171481ec919ccbd06904ae}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_ac781adb849171481ec919ccbd06904ae} 
value\+\_\+iterator {\bfseries iter} \{\}
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_ae5cda98fa74051d037c0c444c67efb15}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_ae5cda98fa74051d037c0c444c67efb15} 
class {\bfseries value}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a7c20332b4481f29ace969e40cfce5f5f}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a7c20332b4481f29ace969e40cfce5f5f} 
class {\bfseries document}
\item 
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa14649f261616070b04829c9ba6b28da}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa14649f261616070b04829c9ba6b28da} 
struct {\bfseries simdjson\+\_\+result$<$ object $>$}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A forward-\/only JSON object field iterator. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a11782810fac89fc282535e42d25bab56}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a11782810fac89fc282535e42d25bab56} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!object@{object}}
\index{object@{object}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{object()}{object()}}
{\footnotesize\ttfamily simdjson\+\_\+inline simdjson\+::fallback\+::ondemand\+::object\+::object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Create a new invalid object.

Exists so you can declare a variable and later assign to it before use. 

\doxysubsection{Member Function Documentation}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a156a49869fabb446d8501ae4e4f82c57}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a156a49869fabb446d8501ae4e4f82c57} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!at\_path@{at\_path}}
\index{at\_path@{at\_path}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{at\_path()}{at\_path()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::object\+::at\+\_\+path (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{json\+\_\+path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get the value associated with the given JSONPath expression. We only support JSONPath queries that trivially convertible to JSON Pointer queries\+: key names and array indices.

\begin{DoxyReturn}{Returns}
The value associated with the given JSONPath expression, or\+:
\begin{DoxyItemize}
\item INVALID\+\_\+\+JSON\+\_\+\+POINTER if the JSONPath to JSON Pointer conversion fails
\item NO\+\_\+\+SUCH\+\_\+\+FIELD if a field does not exist in an object
\item INDEX\+\_\+\+OUT\+\_\+\+OF\+\_\+\+BOUNDS if an array index is larger than an array length
\item INCORRECT\+\_\+\+TYPE if a non-\/integer is used to access an array 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a9ebe7310eaf678a3fbe0935738bd5818}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a9ebe7310eaf678a3fbe0935738bd5818} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!at\_pointer@{at\_pointer}}
\index{at\_pointer@{at\_pointer}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{at\_pointer()}{at\_pointer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::object\+::at\+\_\+pointer (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{json\+\_\+pointer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get the value associated with the given JSON pointer. We use the RFC 6901 \href{https://tools.ietf.org/html/rfc6901}{\texttt{ https\+://tools.\+ietf.\+org/html/rfc6901}} standard, interpreting the current node as the root of its own JSON document.

\doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{ondemand\+::parser} parser; auto json = R"{}(\{ "{}foo"{}\+: \{ "{}a"{}\+: \mbox{[} 10, 20, 30 \mbox{]} \}\})"{}\+\_\+padded; auto doc = parser.\+iterate(json); doc.\+at\+\_\+pointer("{}/foo/a/1"{}) == 20

It is allowed for a key to be the empty string\+:

\doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1parser}{ondemand\+::parser} parser; auto json = R"{}(\{ "{}"{}\+: \{ "{}a"{}\+: \mbox{[} 10, 20, 30 \mbox{]} \}\})"{}\+\_\+padded; auto doc = parser.\+iterate(json); doc.\+at\+\_\+pointer("{}//a/1"{}) == 20

Note that \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a9ebe7310eaf678a3fbe0935738bd5818}{at\+\_\+pointer()} called on the document automatically calls the document\textquotesingle{}s rewind method between each call. It invalidates all previously accessed arrays, objects and values that have not been consumed. Yet it is not the case when calling at\+\_\+pointer on an object instance\+: there is no rewind and no invalidation.

You may call at\+\_\+pointer more than once on an object, but each time the pointer is advanced to be within the value matched by the key indicated by the JSON pointer query. Thus any preceding key (as well as the current key) can no longer be used with following JSON pointer calls.

Also note that \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a9ebe7310eaf678a3fbe0935738bd5818}{at\+\_\+pointer()} relies on \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a56bd93c4ad188370f08e83239d1f6843}{find\+\_\+field()} which implies that we do not unescape keys when matching.

\begin{DoxyReturn}{Returns}
The value associated with the given JSON pointer, or\+:
\begin{DoxyItemize}
\item NO\+\_\+\+SUCH\+\_\+\+FIELD if a field does not exist in an object
\item INDEX\+\_\+\+OUT\+\_\+\+OF\+\_\+\+BOUNDS if an array index is larger than an array length
\item INCORRECT\+\_\+\+TYPE if a non-\/integer is used to access an array
\item INVALID\+\_\+\+JSON\+\_\+\+POINTER if the JSON pointer is invalid and cannot be parsed 
\end{DoxyItemize}
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_aed92810d20a93f72fbc168d2aca426a5}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_aed92810d20a93f72fbc168d2aca426a5} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!consume@{consume}}
\index{consume@{consume}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{consume()}{consume()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} simdjson\+::fallback\+::ondemand\+::object\+::consume (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [noexcept]}}

Go to the end of the object, no matter where you are right now. whenever you are pointing at a key, calling skip\+\_\+child() is unsafe because you will hit a string and you will assume that it is string value, and this mistake will lead you to make bad depth computation.

We want to \textquotesingle{}consume\textquotesingle{} the key. We could really just do \+\_\+json\+\_\+iter-\/\texorpdfstring{$>$}{>}return\+\_\+current\+\_\+and\+\_\+advance(); at this point, but, for clarity, we will use the high-\/level API to eat the key. We assume that the compiler optimizes away most of the work.\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3bf0a05579330efd8e79e2255f336cd0}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3bf0a05579330efd8e79e2255f336cd0} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!count\_fields@{count\_fields}}
\index{count\_fields@{count\_fields}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{count\_fields()}{count\_fields()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ size\+\_\+t $>$ simdjson\+::fallback\+::ondemand\+::object\+::count\+\_\+fields (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [noexcept]}}

This method scans the object and counts the number of key-\/value pairs. The count\+\_\+fields method should always be called before you have begun iterating through the object\+: it is expected that you are pointing at the beginning of the object. The runtime complexity is linear in the size of the object. After calling this function, if successful, the object is \textquotesingle{}rewinded\textquotesingle{} at its beginning as if it had never been accessed. If the JSON is malformed (e.\+g., there is a missing comma), then an error is returned and it is no longer safe to continue.

To check that an object is empty, it is more performant to use the \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a8b28b7377207fea100d882230f15897b}{is\+\_\+empty()} method.

Performance hint\+: You should only call \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3bf0a05579330efd8e79e2255f336cd0}{count\+\_\+fields()} as a last resort as it may require scanning the document twice or more. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a56bd93c4ad188370f08e83239d1f6843}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a56bd93c4ad188370f08e83239d1f6843} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!find\_field@{find\_field}}
\index{find\_field@{find\_field}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{find\_field()}{find\_field()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::object\+::find\+\_\+field (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{key }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [noexcept]}}

Look up a field by name on an object (order-\/sensitive).

The following code reads z, then y, then x, and thus will not retrieve x or y if fed the JSON {\ttfamily \{ "{}x"{}\+: 1, "{}y"{}\+: 2, "{}z"{}\+: 3 \}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{simdjson::ondemand::parser\ parser;}
\DoxyCodeLine{\textcolor{keyword}{auto}\ obj\ =\ parser.parse(R\textcolor{stringliteral}{"{}(\ \{\ "{}x"{}:\ 1,\ "{}y"{}:\ 2,\ "{}z"{}:\ 3\ \}\ )"{}\_padded);}}
\DoxyCodeLine{\textcolor{stringliteral}{}\textcolor{keywordtype}{double}\ z\ =\ obj.find\_field(\textcolor{stringliteral}{"{}z"{}});}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ y\ =\ obj.find\_field(\textcolor{stringliteral}{"{}y"{}});}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ x\ =\ obj.find\_field(\textcolor{stringliteral}{"{}x"{}});}

\end{DoxyCode}
 If you have multiple fields with a matching key (\{"{}x"{}\+: 1, "{}x"{}\+: 1\}) be mindful that only one field is returned.

{\bfseries{Raw Keys\+:}} The lookup will be done against the {\itshape raw} key, and will not unescape keys. e.\+g. {\ttfamily object\mbox{[}"{}a"{}\mbox{]}} will match {\ttfamily \{ "{}a"{}\+: 1 \}}, but will {\itshape not} match {\ttfamily \{ "{}\textbackslash{}u0061"{}\+: 1 \}}.

You must consume the fields on an object one at a time. A request for a new key invalidates previous field values\+: it makes them unsafe. The value instance you get from {\ttfamily content\mbox{[}"{}bids"{}\mbox{]}} becomes invalid when you call {\ttfamily content\mbox{[}"{}asks"{}\mbox{]}}. The array given by content\mbox{[}"{}bids"{}\mbox{]}.get\+\_\+array() should not be accessed after you have called content\mbox{[}"{}asks"{}\mbox{]}.get\+\_\+array(). You can detect such mistakes by first compiling and running the code in Debug mode (or with the macro {\ttfamily SIMDJSON\+\_\+\+DEVELOPMENT\+\_\+\+CHECKS} set to 1)\+: an OUT\+\_\+\+OF\+\_\+\+ORDER\+\_\+\+ITERATION error is generated.

You are expected to access keys only once. You should access the value corresponding to a key a single time. Doing object\mbox{[}"{}mykey"{}\mbox{]}.\doxylink{namespacesimdjson_ade4516933f53705eacfaed65ed14962d}{to\+\_\+string()} and then again object\mbox{[}"{}mykey"{}\mbox{]}.\doxylink{namespacesimdjson_ade4516933f53705eacfaed65ed14962d}{to\+\_\+string()} is an error.


\begin{DoxyParams}{Parameters}
{\em key} & The key to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the field, or NO\+\_\+\+SUCH\+\_\+\+FIELD if the field is not in the object. 
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3a1290092ed5d9cf8c80ec3d9811dd2b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a3a1290092ed5d9cf8c80ec3d9811dd2b} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!find\_field\_unordered@{find\_field\_unordered}}
\index{find\_field\_unordered@{find\_field\_unordered}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{find\_field\_unordered()}{find\_field\_unordered()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1value}{value}} $>$ simdjson\+::fallback\+::ondemand\+::object\+::find\+\_\+field\+\_\+unordered (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{key }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [noexcept]}}

Look up a field by name on an object, without regard to key order.

{\bfseries{Performance Notes\+:}} This is a bit less performant than \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a56bd93c4ad188370f08e83239d1f6843}{find\+\_\+field()}, though its effect varies and often appears negligible. It starts out normally, starting out at the last field; but if the field is not found, it scans from the beginning of the object to see if it missed it. That missing case has a non-\/cache-\/friendly bump and lots of extra scanning, especially if the object in question is large. The fact that the extra code is there also bumps the executable size.

It is the default, however, because it would be highly surprising (and hard to debug) if the default behavior failed to look up a field just because it was in the wrong order--and many APIs assume this. Therefore, you must be explicit if you want to treat objects as out of order.

Use \doxylink{classsimdjson_1_1fallback_1_1ondemand_1_1object_a56bd93c4ad188370f08e83239d1f6843}{find\+\_\+field()} if you are sure fields will be in order (or are willing to treat it as if the field was not there when they are not in order).

If you have multiple fields with a matching key (\{"{}x"{}\+: 1, "{}x"{}\+: 1\}) be mindful that only one field is returned.

You must consume the fields on an object one at a time. A request for a new key invalidates previous field values\+: it makes them unsafe. The value instance you get from {\ttfamily content\mbox{[}"{}bids"{}\mbox{]}} becomes invalid when you call {\ttfamily content\mbox{[}"{}asks"{}\mbox{]}}. The array given by content\mbox{[}"{}bids"{}\mbox{]}.get\+\_\+array() should not be accessed after you have called content\mbox{[}"{}asks"{}\mbox{]}.get\+\_\+array(). You can detect such mistakes by first compiling and running the code in Debug mode (or with the macro {\ttfamily SIMDJSON\+\_\+\+DEVELOPMENT\+\_\+\+CHECKS} set to 1)\+: an OUT\+\_\+\+OF\+\_\+\+ORDER\+\_\+\+ITERATION error is generated.

You are expected to access keys only once. You should access the value corresponding to a key a single time. Doing object\mbox{[}"{}mykey"{}\mbox{]}.\doxylink{namespacesimdjson_ade4516933f53705eacfaed65ed14962d}{to\+\_\+string()} and then again object\mbox{[}"{}mykey"{}\mbox{]}.\doxylink{namespacesimdjson_ade4516933f53705eacfaed65ed14962d}{to\+\_\+string()} is an error.


\begin{DoxyParams}{Parameters}
{\em key} & The key to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the field, or NO\+\_\+\+SUCH\+\_\+\+FIELD if the field is not in the object. 
\end{DoxyReturn}
\Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a8b28b7377207fea100d882230f15897b}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a8b28b7377207fea100d882230f15897b} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!is\_empty@{is\_empty}}
\index{is\_empty@{is\_empty}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{is\_empty()}{is\_empty()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::object\+::is\+\_\+empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

This method scans the beginning of the object and checks whether the object is empty. The runtime complexity is constant time. After calling this function, if successful, the object is \textquotesingle{}rewinded\textquotesingle{} at its beginning as if it had never been accessed. If the JSON is malformed (e.\+g., there is a missing comma), then an error is returned and it is no longer safe to continue. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_a294db4609b890ec94c1aeb44b3b2caea}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_a294db4609b890ec94c1aeb44b3b2caea} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!raw\_json@{raw\_json}}
\index{raw\_json@{raw\_json}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{raw\_json()}{raw\_json()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ std\+::string\+\_\+view $>$ simdjson\+::fallback\+::ondemand\+::object\+::raw\+\_\+json (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Consumes the object and returns a string\+\_\+view instance corresponding to the object as represented in JSON. It points inside the original byte array containing the JSON document. \Hypertarget{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa6fb23f375d581d1a664ca3cd9983b53}\label{classsimdjson_1_1fallback_1_1ondemand_1_1object_aa6fb23f375d581d1a664ca3cd9983b53} 
\index{simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}!reset@{reset}}
\index{reset@{reset}!simdjson::fallback::ondemand::object@{simdjson::fallback::ondemand::object}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::object\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) \&\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Reset the iterator so that we are pointing back at the beginning of the object. You should still consume values only once even if you can iterate through the object more than once. If you unescape a string within the object more than once, you have unsafe code. Note that rewinding an object means that you may need to reparse it anew\+: it is not a free operation.

\begin{DoxyReturn}{Returns}
true if the object contains some elements (not empty) 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/corpus-\/cleaner/corpus\+\_\+cleaner/simdjson.\+h\end{DoxyCompactItemize}
