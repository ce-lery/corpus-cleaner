\doxysection{Object iteration}
\hypertarget{group__object}{}\label{group__object}\index{Object iteration@{Object iteration}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_ga2472f674652275b2cc41e0a9184be23d}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::start\+\_\+object}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_gae6bc305d46e5de7dfbfdd4c69e01c14a}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::start\+\_\+root\+\_\+object}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} \mbox{\hyperlink{group__object_ga8fa358b704c109d72248534aa638ed58}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::check\+\_\+root\+\_\+object}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_ga071f7504e3b96ee5182e53f9cf8b6614}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::started\+\_\+object}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_gaf730c8b15a1b01dfb54fc0446ef9a451}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::started\+\_\+root\+\_\+object}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_ga36df90d2993f6a790ea55ff90e44b221}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::has\+\_\+next\+\_\+field}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}} $>$ \mbox{\hyperlink{group__object_gafda54a77512f52a582ec62765fcebe8e}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::field\+\_\+key}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} \mbox{\hyperlink{group__object_ga981bc273dd6bd845b39b850f1da53171}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::field\+\_\+value}} () noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} \mbox{\hyperlink{group__object_ga4eac92834c85aaab1a1159a0b0a840bf}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::find\+\_\+field}} (const std\+::string\+\_\+view key) noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_ga1c8524a3197124f6a3bcf6e0dfab6f5a}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::find\+\_\+field\+\_\+raw}} (const std\+::string\+\_\+view key) noexcept
\item 
simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ \mbox{\hyperlink{group__object_gab201cb397d95cf8ce7b9c4e8be8e50d7}{simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::find\+\_\+field\+\_\+unordered\+\_\+raw}} (const std\+::string\+\_\+view key) noexcept
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Methods to iterate and find object fields. These methods generally {\itshape assume} the value is actually an object; the caller is responsible for keeping track of that fact. 

\doxysubsection{Function Documentation}
\Hypertarget{group__object_ga8fa358b704c109d72248534aa638ed58}\label{group__object_ga8fa358b704c109d72248534aa638ed58} 
\index{Object iteration@{Object iteration}!check\_root\_object@{check\_root\_object}}
\index{check\_root\_object@{check\_root\_object}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{check\_root\_object()}{check\_root\_object()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::check\+\_\+root\+\_\+object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Checks whether an object could be started from the root. May be called by start\+\_\+root\+\_\+object.

\begin{DoxyReturn}{Returns}
SUCCESS if it is possible to safely start an object from the root (document level). @error INCORRECT\+\_\+\+TYPE if there is no opening \{ @error TAPE\+\_\+\+ERROR if there is no matching \} at end of document 
\end{DoxyReturn}
\Hypertarget{group__object_gafda54a77512f52a582ec62765fcebe8e}\label{group__object_gafda54a77512f52a582ec62765fcebe8e} 
\index{Object iteration@{Object iteration}!field\_key@{field\_key}}
\index{field\_key@{field\_key}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{field\_key()}{field\_key()}}
{\footnotesize\ttfamily SIMDJSON\+\_\+\+POP\+\_\+\+DISABLE\+\_\+\+WARNINGS simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ \mbox{\hyperlink{classsimdjson_1_1fallback_1_1ondemand_1_1raw__json__string}{raw\+\_\+json\+\_\+string}} $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::field\+\_\+key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Get the current field\textquotesingle{}s key. \Hypertarget{group__object_ga981bc273dd6bd845b39b850f1da53171}\label{group__object_ga981bc273dd6bd845b39b850f1da53171} 
\index{Object iteration@{Object iteration}!field\_value@{field\_value}}
\index{field\_value@{field\_value}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{field\_value()}{field\_value()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::field\+\_\+value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Pass the \+: in the field and move to its value. \Hypertarget{group__object_ga4eac92834c85aaab1a1159a0b0a840bf}\label{group__object_ga4eac92834c85aaab1a1159a0b0a840bf} 
\index{Object iteration@{Object iteration}!find\_field@{find\_field}}
\index{find\_field@{find\_field}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{find\_field()}{find\_field()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{namespacesimdjson_a7b735a3a50ba79e3f7f14df5f77d8da9}{error\+\_\+code}} simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::find\+\_\+field (\begin{DoxyParamCaption}\item[{const std\+::string\+\_\+view}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Find the next field with the given key.

Assumes you have called next\+\_\+field() or otherwise matched the previous value.

This means the iterator must be sitting at the next key\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{\ \textcolor{stringliteral}{"{}a"{}}:\ 1,\ \textcolor{stringliteral}{"{}b"{}}:\ 2\ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \string^}

\end{DoxyCode}


Key is {\itshape raw JSON,} meaning it will be matched against the verbatim JSON without attempting to unescape it. This works well for typical ASCII and UTF-\/8 keys (almost all of them), but may fail to match some keys with escapes (\textbackslash{}u, ~\newline
, etc.). \Hypertarget{group__object_ga1c8524a3197124f6a3bcf6e0dfab6f5a}\label{group__object_ga1c8524a3197124f6a3bcf6e0dfab6f5a} 
\index{Object iteration@{Object iteration}!find\_field\_raw@{find\_field\_raw}}
\index{find\_field\_raw@{find\_field\_raw}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{find\_field\_raw()}{find\_field\_raw()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::find\+\_\+field\+\_\+raw (\begin{DoxyParamCaption}\item[{const std\+::string\+\_\+view}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Find the next field with the given key, {\itshape without} unescaping. This assumes object order\+: it will not find the field if it was already passed when looking for some {\itshape other} field.

Assumes you have called next\+\_\+field() or otherwise matched the previous value.

This means the iterator must be sitting at the next key\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{\ \textcolor{stringliteral}{"{}a"{}}:\ 1,\ \textcolor{stringliteral}{"{}b"{}}:\ 2\ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \string^}

\end{DoxyCode}


Key is {\itshape raw JSON,} meaning it will be matched against the verbatim JSON without attempting to unescape it. This works well for typical ASCII and UTF-\/8 keys (almost all of them), but may fail to match some keys with escapes (\textbackslash{}u, ~\newline
, etc.). \Hypertarget{group__object_gab201cb397d95cf8ce7b9c4e8be8e50d7}\label{group__object_gab201cb397d95cf8ce7b9c4e8be8e50d7} 
\index{Object iteration@{Object iteration}!find\_field\_unordered\_raw@{find\_field\_unordered\_raw}}
\index{find\_field\_unordered\_raw@{find\_field\_unordered\_raw}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{find\_field\_unordered\_raw()}{find\_field\_unordered\_raw()}}
{\footnotesize\ttfamily SIMDJSON\+\_\+\+PUSH\+\_\+\+DISABLE\+\_\+\+WARNINGS SIMDJSON\+\_\+\+DISABLE\+\_\+\+STRICT\+\_\+\+OVERFLOW\+\_\+\+WARNING simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::find\+\_\+field\+\_\+unordered\+\_\+raw (\begin{DoxyParamCaption}\item[{const std\+::string\+\_\+view}]{key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Find the field with the given key without regard to order, and {\itshape without} unescaping.

This is an unordered object lookup\+: if the field is not found initially, it will cycle around and scan from the beginning.

Assumes you have called next\+\_\+field() or otherwise matched the previous value.

This means the iterator must be sitting at the next key\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{\ \textcolor{stringliteral}{"{}a"{}}:\ 1,\ \textcolor{stringliteral}{"{}b"{}}:\ 2\ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \string^}

\end{DoxyCode}


Key is {\itshape raw JSON,} meaning it will be matched against the verbatim JSON without attempting to unescape it. This works well for typical ASCII and UTF-\/8 keys (almost all of them), but may fail to match some keys with escapes (\textbackslash{}u, ~\newline
, etc.). When find\+\_\+field\+\_\+unordered\+\_\+raw is called, we can either be pointing at the first key, pointing outside (at the closing brace) or if a key was matched we can be either pointing right afterthe \textquotesingle{}\+:\textquotesingle{} right before the value (that we need skip), or we may have consumed the value and we might be at a comma or at the final brace (ready for a call to \doxylink{group__object_ga36df90d2993f6a790ea55ff90e44b221}{has\+\_\+next\+\_\+field()}).\Hypertarget{group__object_ga36df90d2993f6a790ea55ff90e44b221}\label{group__object_ga36df90d2993f6a790ea55ff90e44b221} 
\index{Object iteration@{Object iteration}!has\_next\_field@{has\_next\_field}}
\index{has\_next\_field@{has\_next\_field}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{has\_next\_field()}{has\_next\_field()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::has\+\_\+next\+\_\+field (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Moves to the next field in an object.

Looks for , and \}. If \} is found, the object is finished and the iterator advances past it. Otherwise, it advances to the next value.

\begin{DoxyReturn}{Returns}
whether there is another field in the object. @error TAPE\+\_\+\+ERROR If there is a comma missing between fields. @error TAPE\+\_\+\+ERROR If there is a comma, but not enough tokens remaining to have a key, \+:, and value. 
\end{DoxyReturn}
\Hypertarget{group__object_ga2472f674652275b2cc41e0a9184be23d}\label{group__object_ga2472f674652275b2cc41e0a9184be23d} 
\index{Object iteration@{Object iteration}!start\_object@{start\_object}}
\index{start\_object@{start\_object}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{start\_object()}{start\_object()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::start\+\_\+object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Start an object iteration.

\begin{DoxyReturn}{Returns}
Whether the object had any fields (returns false for empty). @error INCORRECT\+\_\+\+TYPE if there is no opening \{ 
\end{DoxyReturn}
\Hypertarget{group__object_gae6bc305d46e5de7dfbfdd4c69e01c14a}\label{group__object_gae6bc305d46e5de7dfbfdd4c69e01c14a} 
\index{Object iteration@{Object iteration}!start\_root\_object@{start\_root\_object}}
\index{start\_root\_object@{start\_root\_object}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{start\_root\_object()}{start\_root\_object()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::start\+\_\+root\+\_\+object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Start an object iteration from the root.

\begin{DoxyReturn}{Returns}
Whether the object had any fields (returns false for empty). @error INCORRECT\+\_\+\+TYPE if there is no opening \{ @error TAPE\+\_\+\+ERROR if there is no matching \} at end of document 
\end{DoxyReturn}
\Hypertarget{group__object_ga071f7504e3b96ee5182e53f9cf8b6614}\label{group__object_ga071f7504e3b96ee5182e53f9cf8b6614} 
\index{Object iteration@{Object iteration}!started\_object@{started\_object}}
\index{started\_object@{started\_object}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{started\_object()}{started\_object()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::started\+\_\+object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Start an object iteration after the user has already checked and moved past the \{.

Does not move the iterator unless the object is empty (\{\}).

\begin{DoxyReturn}{Returns}
Whether the object had any fields (returns false for empty). @error INCOMPLETE\+\_\+\+ARRAY\+\_\+\+OR\+\_\+\+OBJECT If there are no more tokens (implying the {\itshape parent} array or object is incomplete). 
\end{DoxyReturn}
\Hypertarget{group__object_gaf730c8b15a1b01dfb54fc0446ef9a451}\label{group__object_gaf730c8b15a1b01dfb54fc0446ef9a451} 
\index{Object iteration@{Object iteration}!started\_root\_object@{started\_root\_object}}
\index{started\_root\_object@{started\_root\_object}!Object iteration@{Object iteration}}
\doxysubsubsection{\texorpdfstring{started\_root\_object()}{started\_root\_object()}}
{\footnotesize\ttfamily simdjson\+\_\+warn\+\_\+unused simdjson\+\_\+inline \mbox{\hyperlink{structsimdjson_1_1simdjson__result}{simdjson\+\_\+result}}$<$ bool $>$ simdjson\+::fallback\+::ondemand\+::value\+\_\+iterator\+::started\+\_\+root\+\_\+object (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Start an object iteration from the root, after the user has already checked and moved past the \{.

Does not move the iterator unless the object is empty (\{\}).

\begin{DoxyReturn}{Returns}
Whether the object had any fields (returns false for empty). @error INCOMPLETE\+\_\+\+ARRAY\+\_\+\+OR\+\_\+\+OBJECT If there are no more tokens (implying the {\itshape parent} array or object is incomplete). 
\end{DoxyReturn}
